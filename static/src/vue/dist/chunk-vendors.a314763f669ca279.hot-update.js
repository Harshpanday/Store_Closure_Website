/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdatefrontend"]("chunk-vendors",{

/***/ "./node_modules/emitter-component/index.js":
/*!*************************************************!*\
  !*** ./node_modules/emitter-component/index.js ***!
  \*************************************************/
/***/ (function(module) {

eval("\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW1pdHRlci1jb21wb25lbnQvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2VtaXR0ZXItY29tcG9uZW50L2luZGV4LmpzP2NhYzciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/emitter-component/index.js\n");

/***/ }),

/***/ "./node_modules/stream/index.js":
/*!**************************************!*\
  !*** ./node_modules/stream/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Emitter = __webpack_require__(/*! emitter */ \"./node_modules/emitter-component/index.js\");\n\nfunction Stream() {\n  Emitter.call(this);\n}\nStream.prototype = new Emitter();\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (!this.hasListeners('error')) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.off('data', ondata);\n    dest.off('drain', ondrain);\n\n    source.off('end', onend);\n    source.off('close', onclose);\n\n    source.off('error', onerror);\n    dest.off('error', onerror);\n\n    source.off('end', cleanup);\n    source.off('close', cleanup);\n\n    dest.off('end', cleanup);\n    dest.off('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RyZWFtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc3RyZWFtL2luZGV4LmpzP2IxNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlcicpO1xuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblN0cmVhbS5wcm90b3R5cGUgPSBuZXcgRW1pdHRlcigpO1xubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoJ2Vycm9yJykpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLm9mZignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5vZmYoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2Uub2ZmKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9mZignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5vZmYoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5vZmYoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2Uub2ZmKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2Uub2ZmKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5vZmYoJ2VuZCcsIGNsZWFudXApO1xuICAgIGRlc3Qub2ZmKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2VuZCcsIGNsZWFudXApO1xuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/stream/index.js\n");

/***/ }),

/***/ "./node_modules/csv/dist/cjs/index.cjs":
/*!*********************************************!*\
  !*** ./node_modules/csv/dist/cjs/index.cjs ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar stream = __webpack_require__(/*! stream */ \"./node_modules/stream/index.js\");\nvar util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nconst init_state$1 = (options) => {\n  // State\n  return {\n    start_time: options.duration ? Date.now() : null,\n    fixed_size_buffer: '',\n    count_written: 0,\n    count_created: 0,\n  };\n};\n\n// Generate a random number between 0 and 1 with 2 decimals. The function is idempotent if it detect the \"seed\" option.\nconst random = function(options={}){\n  if(options.seed){\n    return options.seed = options.seed * Math.PI * 100 % 100 / 100;\n  }else {\n    return Math.random();\n  }\n};\n\nconst types = {\n  // Generate an ASCII value.\n  ascii: function({options}){\n    const column = [];\n    const nb_chars = Math.ceil(random(options) * options.maxWordLength);\n    for(let i=0; i<nb_chars; i++){\n      const char = Math.floor(random(options) * 32);\n      column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));\n    }\n    return column.join('');\n  },\n  // Generate an integer value.\n  int: function({options}){\n    return Math.floor(random(options) * Math.pow(2, 52));\n  },\n  // Generate an boolean value.\n  bool: function({options}){\n    return Math.floor(random(options) * 2);\n  }\n};\n\nconst camelize = function(str){\n  return str.replace(/_([a-z])/gi, function(_, match){\n    return match.toUpperCase();\n  });\n};\n\nconst normalize_options$2 = (opts) => {\n  // Convert Stream Readable options if underscored\n  if(opts.high_water_mark){\n    opts.highWaterMark = opts.high_water_mark;\n  }\n  if(opts.object_mode){\n    opts.objectMode = opts.object_mode;\n  }\n  // Clone and camelize options\n  const options = {};\n  for(const k in opts){\n    options[camelize(k)] = opts[k];\n  }\n  // Normalize options\n  const dft = {\n    columns: 8,\n    delimiter: ',',\n    duration: null,\n    encoding: null,\n    end: null,\n    eof: false,\n    fixedSize: false,\n    length: -1,\n    maxWordLength: 16,\n    rowDelimiter: '\\n',\n    seed: false,\n    sleep: 0,\n  };\n  for(const k in dft){\n    if(options[k] === undefined){\n      options[k] = dft[k];\n    }\n  }\n  // Default values\n  if(options.eof === true){\n    options.eof = options.rowDelimiter;\n  }\n  if(typeof options.columns === 'number'){\n    options.columns = new Array(options.columns);\n  }\n  const accepted_header_types = Object.keys(types).filter((t) => (!['super_', 'camelize'].includes(t)));\n  for(let i = 0; i < options.columns.length; i++){\n    const v = options.columns[i] || 'ascii';\n    if(typeof v === 'string'){\n      if(!accepted_header_types.includes(v)){\n        throw Error(`Invalid column type: got \"${v}\", default values are ${JSON.stringify(accepted_header_types)}`);\n      }\n      options.columns[i] = types[v];\n    }\n  }\n  return options;\n};\n\nconst read = (options, state, size, push, close) => {\n  // Already started\n  const data = [];\n  let length = state.fixed_size_buffer.length;\n  if(length !== 0){\n    data.push(state.fixed_size_buffer);\n  }\n  // eslint-disable-next-line\n  while(true){\n    // Time for some rest: flush first and stop later\n    if((state.count_created === options.length) || (options.end && Date.now() > options.end) || (options.duration && Date.now() > state.start_time + options.duration)){\n      // Flush\n      if(data.length){\n        if(options.objectMode){\n          for(const record of data){\n            push(record);\n          }\n        }else {\n          push(data.join('') + (options.eof ? options.eof : ''));\n        }\n        state.end = true;\n      }else {\n        close();\n      }\n      return;\n    }\n    // Create the record\n    let record = [];\n    let recordLength;\n    for(const fn of options.columns){\n      const result = fn({options: options, state: state});\n      const type = typeof result;\n      if(result !== null && type !== 'string' && type !== 'number'){\n        return Error([\n          'INVALID_VALUE:',\n          'values returned by column function must be',\n          'a string, a number or null,',\n          `got ${JSON.stringify(result)}`\n        ].join(' '));\n      }\n      record.push(result);\n    }\n    // Obtain record length\n    if(options.objectMode){\n      recordLength = 0;\n      // recordLength is currently equal to the number of columns\n      // This is wrong and shall equal to 1 record only\n      for(const column of record){\n        recordLength += column.length;\n      }\n    }else {\n      // Stringify the record\n      record = (state.count_created === 0 ? '' : options.rowDelimiter)+record.join(options.delimiter);\n      recordLength = record.length;\n    }\n    state.count_created++;\n    if(length + recordLength > size){\n      if(options.objectMode){\n        data.push(record);\n        for(const record of data){\n          push(record);\n        }\n      }else {\n        if(options.fixedSize){\n          state.fixed_size_buffer = record.substr(size - length);\n          data.push(record.substr(0, size - length));\n        }else {\n          data.push(record);\n        }\n        push(data.join(''));\n      }\n      return;\n    }\n    length += recordLength;\n    data.push(record);\n  }\n};\n\nconst Generator = function(options = {}){\n  this.options = normalize_options$2(options);\n  // Call parent constructor\n  stream.Readable.call(this, this.options);\n  this.state = init_state$1(this.options);\n  return this;\n};\nutil.inherits(Generator, stream.Readable);\n\n// Stop the generation.\nGenerator.prototype.end = function(){\n  this.push(null);\n};\n// Put new data into the read queue.\nGenerator.prototype._read = function(size){\n  const self = this;\n  const err = read(this.options, this.state, size, function(chunk) {\n    self.__push(chunk);\n  }, function(){\n    self.push(null);\n  });\n  if(err){\n    this.destroy(err);\n  }\n};\n// Put new data into the read queue.\nGenerator.prototype.__push = function(record){\n  // console.log('push', record)\n  const push = () => {\n    this.state.count_written++;\n    this.push(record);\n    if(this.state.end === true){\n      return this.push(null);\n    }\n  };\n  this.options.sleep > 0 ? setTimeout(push, this.options.sleep) : push();\n};\n\nconst generate = function(){\n  let options;\n  let callback;\n  if(arguments.length === 2){\n    options = arguments[0];\n    callback = arguments[1];\n  }else if(arguments.length === 1){\n    if(typeof arguments[0] === 'function'){\n      options = {};\n      callback = arguments[0];\n    }else {\n      options = arguments[0];\n    }\n  }else if(arguments.length === 0){\n    options = {};\n  }\n  const generator = new Generator(options);\n  if(callback){\n    const data = [];\n    generator.on('readable', function(){\n      let d; while((d = generator.read()) !== null){\n        data.push(d);\n      }\n    });\n    generator.on('error', callback);\n    generator.on('end', function(){\n      if(generator.options.objectMode){\n        callback(null, data);\n      }else {\n        if(generator.options.encoding){\n          callback(null, data.join(''));\n        }else {\n          callback(null, Buffer.concat(data));\n        }\n      }\n    });\n  }\n  return generator;\n};\n\nconst is_object$1 = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj));\n};\n\nlet CsvError$1 = class CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ').trim();\n    super(message);\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError$1);\n    }\n    this.code = code;\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n};\n\nconst normalize_columns_array = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i];\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true };\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column };\n    }else if(is_object$1(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError$1('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ]);\n      }\n      normalizedColumns[i] = column;\n    }else {\n      throw new CsvError$1('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ]);\n    }\n  }\n  return normalizedColumns;\n};\n\nclass ResizeableBuffer{\n  constructor(size=100){\n    this.size = size;\n    this.length = 0;\n    this.buf = Buffer.allocUnsafe(size);\n  }\n  prepend(val){\n    if(Buffer.isBuffer(val)){\n      const length = this.length + val.length;\n      if(length >= this.size){\n        this.resize();\n        if(length >= this.size){\n          throw Error('INVALID_BUFFER_STATE');\n        }\n      }\n      const buf = this.buf;\n      this.buf = Buffer.allocUnsafe(this.size);\n      val.copy(this.buf, 0);\n      buf.copy(this.buf, val.length);\n      this.length += val.length;\n    }else {\n      const length = this.length++;\n      if(length === this.size){\n        this.resize();\n      }\n      const buf = this.clone();\n      this.buf[0] = val;\n      buf.copy(this.buf,1, 0, length);\n    }\n  }\n  append(val){\n    const length = this.length++;\n    if(length === this.size){\n      this.resize();\n    }\n    this.buf[length] = val;\n  }\n  clone(){\n    return Buffer.from(this.buf.slice(0, this.length));\n  }\n  resize(){\n    const length = this.length;\n    this.size = this.size * 2;\n    const buf = Buffer.allocUnsafe(this.size);\n    this.buf.copy(buf,0, 0, length);\n    this.buf = buf;\n  }\n  toString(encoding){\n    if(encoding){\n      return this.buf.slice(0, this.length).toString(encoding);\n    }else {\n      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));\n    }\n  }\n  toJSON(){\n    return this.toString('utf8');\n  }\n  reset(){\n    this.length = 0;\n  }\n}\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst np = 12;\nconst cr$1 = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl$1 = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\nconst space = 32;\nconst tab = 9;\n\nconst init_state = function(options){\n  return {\n    bomSkipped: false,\n    bufBytesStart: 0,\n    castField: options.cast_function,\n    commenting: false,\n    // Current error encountered by a record\n    error: undefined,\n    enabled: options.from_line === 1,\n    escaping: false,\n    escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n    // columns can be `false`, `true`, `Array`\n    expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n    field: new ResizeableBuffer(20),\n    firstLineToHeaders: options.cast_first_line_to_header,\n    needMoreDataSize: Math.max(\n      // Skip if the remaining buffer smaller than comment\n      options.comment !== null ? options.comment.length : 0,\n      // Skip if the remaining buffer can be delimiter\n      ...options.delimiter.map((delimiter) => delimiter.length),\n      // Skip if the remaining buffer can be escape sequence\n      options.quote !== null ? options.quote.length : 0,\n    ),\n    previousBuf: undefined,\n    quoting: false,\n    stop: false,\n    rawBuffer: new ResizeableBuffer(100),\n    record: [],\n    recordHasError: false,\n    record_length: 0,\n    recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v) => v.length)),\n    trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n    wasQuoting: false,\n    wasRowDelimiter: false,\n    timchars: [\n      Buffer.from(Buffer.from([cr$1], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([nl$1], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([np], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([space], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([tab], 'utf8').toString(), options.encoding),\n    ]\n  };\n};\n\nconst underscore$1 = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase();\n  });\n};\n\nconst normalize_options$1 = function(opts){\n  const options = {};\n  // Merge with user options\n  for(const opt in opts){\n    options[underscore$1(opt)] = opts[opt];\n  }\n  // Normalize option `encoding`\n  // Note: defined first because other options depends on it\n  // to convert chars/strings into buffers.\n  if(options.encoding === undefined || options.encoding === true){\n    options.encoding = 'utf8';\n  }else if(options.encoding === null || options.encoding === false){\n    options.encoding = null;\n  }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n    throw new CsvError$1('CSV_INVALID_OPTION_ENCODING', [\n      'Invalid option encoding:',\n      'encoding must be a string or null to return a buffer,',\n      `got ${JSON.stringify(options.encoding)}`\n    ], options);\n  }\n  // Normalize option `bom`\n  if(options.bom === undefined || options.bom === null || options.bom === false){\n    options.bom = false;\n  }else if(options.bom !== true){\n    throw new CsvError$1('CSV_INVALID_OPTION_BOM', [\n      'Invalid option bom:', 'bom must be true,',\n      `got ${JSON.stringify(options.bom)}`\n    ], options);\n  }\n  // Normalize option `cast`\n  options.cast_function = null;\n  if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n    options.cast = undefined;\n  }else if(typeof options.cast === 'function'){\n    options.cast_function = options.cast;\n    options.cast = true;\n  }else if(options.cast !== true){\n    throw new CsvError$1('CSV_INVALID_OPTION_CAST', [\n      'Invalid option cast:', 'cast must be true or a function,',\n      `got ${JSON.stringify(options.cast)}`\n    ], options);\n  }\n  // Normalize option `cast_date`\n  if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n    options.cast_date = false;\n  }else if(options.cast_date === true){\n    options.cast_date = function(value){\n      const date = Date.parse(value);\n      return !isNaN(date) ? new Date(date) : value;\n    };\n  }else if (typeof options.cast_date !== 'function'){\n    throw new CsvError$1('CSV_INVALID_OPTION_CAST_DATE', [\n      'Invalid option cast_date:', 'cast_date must be true or a function,',\n      `got ${JSON.stringify(options.cast_date)}`\n    ], options);\n  }\n  // Normalize option `columns`\n  options.cast_first_line_to_header = null;\n  if(options.columns === true){\n    // Fields in the first line are converted as-is to columns\n    options.cast_first_line_to_header = undefined;\n  }else if(typeof options.columns === 'function'){\n    options.cast_first_line_to_header = options.columns;\n    options.columns = true;\n  }else if(Array.isArray(options.columns)){\n    options.columns = normalize_columns_array(options.columns);\n  }else if(options.columns === undefined || options.columns === null || options.columns === false){\n    options.columns = false;\n  }else {\n    throw new CsvError$1('CSV_INVALID_OPTION_COLUMNS', [\n      'Invalid option columns:',\n      'expect an array, a function or true,',\n      `got ${JSON.stringify(options.columns)}`\n    ], options);\n  }\n  // Normalize option `group_columns_by_name`\n  if(options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false){\n    options.group_columns_by_name = false;\n  }else if(options.group_columns_by_name !== true){\n    throw new CsvError$1('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'expect an boolean,',\n      `got ${JSON.stringify(options.group_columns_by_name)}`\n    ], options);\n  }else if(options.columns === false){\n    throw new CsvError$1('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'the `columns` mode must be activated.'\n    ], options);\n  }\n  // Normalize option `comment`\n  if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n    options.comment = null;\n  }else {\n    if(typeof options.comment === 'string'){\n      options.comment = Buffer.from(options.comment, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.comment)){\n      throw new CsvError$1('CSV_INVALID_OPTION_COMMENT', [\n        'Invalid option comment:',\n        'comment must be a buffer or a string,',\n        `got ${JSON.stringify(options.comment)}`\n      ], options);\n    }\n  }\n  // Normalize option `delimiter`\n  const delimiter_json = JSON.stringify(options.delimiter);\n  if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n  if(options.delimiter.length === 0){\n    throw new CsvError$1('CSV_INVALID_OPTION_DELIMITER', [\n      'Invalid option delimiter:',\n      'delimiter must be a non empty string or buffer or array of string|buffer,',\n      `got ${delimiter_json}`\n    ], options);\n  }\n  options.delimiter = options.delimiter.map(function(delimiter){\n    if(delimiter === undefined || delimiter === null || delimiter === false){\n      return Buffer.from(',', options.encoding);\n    }\n    if(typeof delimiter === 'string'){\n      delimiter = Buffer.from(delimiter, options.encoding);\n    }\n    if(!Buffer.isBuffer(delimiter) || delimiter.length === 0){\n      throw new CsvError$1('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options);\n    }\n    return delimiter;\n  });\n  // Normalize option `escape`\n  if(options.escape === undefined || options.escape === true){\n    options.escape = Buffer.from('\"', options.encoding);\n  }else if(typeof options.escape === 'string'){\n    options.escape = Buffer.from(options.escape, options.encoding);\n  }else if (options.escape === null || options.escape === false){\n    options.escape = null;\n  }\n  if(options.escape !== null){\n    if(!Buffer.isBuffer(options.escape)){\n      throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n    }\n  }\n  // Normalize option `from`\n  if(options.from === undefined || options.from === null){\n    options.from = 1;\n  }else {\n    if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n      options.from = parseInt(options.from);\n    }\n    if(Number.isInteger(options.from)){\n      if(options.from < 0){\n        throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n      }\n    }else {\n      throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n    }\n  }\n  // Normalize option `from_line`\n  if(options.from_line === undefined || options.from_line === null){\n    options.from_line = 1;\n  }else {\n    if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n      options.from_line = parseInt(options.from_line);\n    }\n    if(Number.isInteger(options.from_line)){\n      if(options.from_line <= 0){\n        throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n      }\n    }else {\n      throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n    }\n  }\n  // Normalize options `ignore_last_delimiters`\n  if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n    options.ignore_last_delimiters = false;\n  }else if(typeof options.ignore_last_delimiters === 'number'){\n    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n    if(options.ignore_last_delimiters === 0){\n      options.ignore_last_delimiters = false;\n    }\n  }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n    throw new CsvError$1('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n      'Invalid option `ignore_last_delimiters`:',\n      'the value must be a boolean value or an integer,',\n      `got ${JSON.stringify(options.ignore_last_delimiters)}`\n    ], options);\n  }\n  if(options.ignore_last_delimiters === true && options.columns === false){\n    throw new CsvError$1('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n      'The option `ignore_last_delimiters`',\n      'requires the activation of the `columns` option'\n    ], options);\n  }\n  // Normalize option `info`\n  if(options.info === undefined || options.info === null || options.info === false){\n    options.info = false;\n  }else if(options.info !== true){\n    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n  }\n  // Normalize option `max_record_size`\n  if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n    options.max_record_size = 0;\n  }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0);else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n    options.max_record_size = parseInt(options.max_record_size);\n  }else {\n    throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n  }\n  // Normalize option `objname`\n  if(options.objname === undefined || options.objname === null || options.objname === false){\n    options.objname = undefined;\n  }else if(Buffer.isBuffer(options.objname)){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty buffer`);\n    }\n    if(options.encoding === null);else {\n      options.objname = options.objname.toString(options.encoding);\n    }\n  }else if(typeof options.objname === 'string'){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty string`);\n    }\n    // Great, nothing to do\n  }else if(typeof options.objname === 'number');else {\n    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n  }\n  if(options.objname !== undefined){\n    if(typeof options.objname === 'number'){\n      if(options.columns !== false){\n        throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');\n      }\n    }else { // A string or a buffer\n      if(options.columns === false){\n        throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');\n      }\n    }\n  }\n  // Normalize option `on_record`\n  if(options.on_record === undefined || options.on_record === null){\n    options.on_record = undefined;\n  }else if(typeof options.on_record !== 'function'){\n    throw new CsvError$1('CSV_INVALID_OPTION_ON_RECORD', [\n      'Invalid option `on_record`:',\n      'expect a function,',\n      `got ${JSON.stringify(options.on_record)}`\n    ], options);\n  }\n  // Normalize option `quote`\n  if(options.quote === null || options.quote === false || options.quote === ''){\n    options.quote = null;\n  }else {\n    if(options.quote === undefined || options.quote === true){\n      options.quote = Buffer.from('\"', options.encoding);\n    }else if(typeof options.quote === 'string'){\n      options.quote = Buffer.from(options.quote, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.quote)){\n      throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n    }\n  }\n  // Normalize option `raw`\n  if(options.raw === undefined || options.raw === null || options.raw === false){\n    options.raw = false;\n  }else if(options.raw !== true){\n    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n  }\n  // Normalize option `record_delimiter`\n  if(options.record_delimiter === undefined){\n    options.record_delimiter = [];\n  }else if(typeof options.record_delimiter === 'string' || Buffer.isBuffer(options.record_delimiter)){\n    if(options.record_delimiter.length === 0){\n      throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer,',\n        `got ${JSON.stringify(options.record_delimiter)}`\n      ], options);\n    }\n    options.record_delimiter = [options.record_delimiter];\n  }else if(!Array.isArray(options.record_delimiter)){\n    throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n      'Invalid option `record_delimiter`:',\n      'value must be a string, a buffer or array of string|buffer,',\n      `got ${JSON.stringify(options.record_delimiter)}`\n    ], options);\n  }\n  options.record_delimiter = options.record_delimiter.map(function(rd, i){\n    if(typeof rd !== 'string' && ! Buffer.isBuffer(rd)){\n      throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a string, a buffer or array of string|buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }else if(rd.length === 0){\n      throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }\n    if(typeof rd === 'string'){\n      rd = Buffer.from(rd, options.encoding);\n    }\n    return rd;\n  });\n  // Normalize option `relax_column_count`\n  if(typeof options.relax_column_count === 'boolean');else if(options.relax_column_count === undefined || options.relax_column_count === null){\n    options.relax_column_count = false;\n  }else {\n    throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n  }\n  if(typeof options.relax_column_count_less === 'boolean');else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n    options.relax_column_count_less = false;\n  }else {\n    throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n  }\n  if(typeof options.relax_column_count_more === 'boolean');else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n    options.relax_column_count_more = false;\n  }else {\n    throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n  }\n  // Normalize option `relax_quotes`\n  if(typeof options.relax_quotes === 'boolean');else if(options.relax_quotes === undefined || options.relax_quotes === null){\n    options.relax_quotes = false;\n  }else {\n    throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);\n  }\n  // Normalize option `skip_empty_lines`\n  if(typeof options.skip_empty_lines === 'boolean');else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n    options.skip_empty_lines = false;\n  }else {\n    throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n  }\n  // Normalize option `skip_records_with_empty_values`\n  if(typeof options.skip_records_with_empty_values === 'boolean');else if(options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null){\n    options.skip_records_with_empty_values = false;\n  }else {\n    throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);\n  }\n  // Normalize option `skip_records_with_error`\n  if(typeof options.skip_records_with_error === 'boolean');else if(options.skip_records_with_error === undefined || options.skip_records_with_error === null){\n    options.skip_records_with_error = false;\n  }else {\n    throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);\n  }\n  // Normalize option `rtrim`\n  if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n    options.rtrim = false;\n  }else if(options.rtrim !== true){\n    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n  }\n  // Normalize option `ltrim`\n  if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n    options.ltrim = false;\n  }else if(options.ltrim !== true){\n    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n  }\n  // Normalize option `trim`\n  if(options.trim === undefined || options.trim === null || options.trim === false){\n    options.trim = false;\n  }else if(options.trim !== true){\n    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n  }\n  // Normalize options `trim`, `ltrim` and `rtrim`\n  if(options.trim === true && opts.ltrim !== false){\n    options.ltrim = true;\n  }else if(options.ltrim !== true){\n    options.ltrim = false;\n  }\n  if(options.trim === true && opts.rtrim !== false){\n    options.rtrim = true;\n  }else if(options.rtrim !== true){\n    options.rtrim = false;\n  }\n  // Normalize option `to`\n  if(options.to === undefined || options.to === null){\n    options.to = -1;\n  }else {\n    if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n      options.to = parseInt(options.to);\n    }\n    if(Number.isInteger(options.to)){\n      if(options.to <= 0){\n        throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n      }\n    }else {\n      throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n    }\n  }\n  // Normalize option `to_line`\n  if(options.to_line === undefined || options.to_line === null){\n    options.to_line = -1;\n  }else {\n    if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n      options.to_line = parseInt(options.to_line);\n    }\n    if(Number.isInteger(options.to_line)){\n      if(options.to_line <= 0){\n        throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n      }\n    }else {\n      throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n    }\n  }\n  return options;\n};\n\nconst isRecordEmpty = function(record){\n  return record.every((field) => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform$1 = function(original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options$1(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function(i, bufLen, end){\n      if(end) return false;\n      const {encoding, escape, quote} = this.options;\n      const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? ((escape === null ? 0 : escape.length) + quote.length) : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function(nextBuf, end, push, close){\n      const {bom, encoding, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;\n      let {comment, escape, quote, record_delimiter} = this.options;\n      const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;\n      let buf;\n      if(previousBuf === undefined){\n        if(nextBuf === undefined){\n          // Handle empty string\n          close();\n          return;\n        }else {\n          buf = nextBuf;\n        }\n      }else if(previousBuf !== undefined && nextBuf === undefined){\n        buf = previousBuf;\n      }else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if(bomSkipped === false){\n        if(bom === false){\n          this.state.bomSkipped = true;\n        }else if(buf.length < 3){\n          // No enough data\n          if(end === false){\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        }else {\n          for(const encoding in boms){\n            if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options$1({...this.original_options, encoding: encoding});\n              // Options will re-evaluate the Buffer with the new encoding\n              ({comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for(pos = 0; pos < bufLen; pos++){\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if(this.__needMoreData(pos, bufLen, end)){\n          break;\n        }\n        if(this.state.wasRowDelimiter === true){\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if(to_line !== -1 && this.info.lines > to_line){\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if(this.state.quoting === false && record_delimiter.length === 0){\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if(record_delimiterCount){\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if(raw === true){\n          rawBuffer.append(chr);\n        }\n        if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if(this.state.escaping === true){\n          this.state.escaping = false;\n        }else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n            if(escapeIsQuote){\n              if(this.__isQuote(buf, pos+escape.length)){\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            }else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if(this.state.commenting === false && this.__isQuote(buf, pos)){\n            if(this.state.quoting === true){\n              const nextChr = buf[pos+quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n                pos += escape.length - 1;\n              }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              }else if(relax_quotes === false){\n                const err = this.__error(\n                  new CsvError$1('CSV_INVALID_CLOSING_QUOTE', [\n                    'Invalid Closing Quote:',\n                    `got \"${String.fromCharCode(nextChr)}\"`,\n                    `at line ${this.info.lines}`,\n                    'instead of delimiter, record delimiter, trimable character',\n                    '(if activated) or comment',\n                  ], this.options, this.__infoField())\n                );\n                if(err !== undefined) return err;\n              }else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            }else {\n              if(this.state.field.length !== 0){\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if(relax_quotes === false){\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError$1('INVALID_OPENING_QUOTE', [\n                      'Invalid Opening Quote:',\n                      `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                      bom ? `(${bom} bom)` : undefined\n                    ], this.options, info, {\n                      field: this.state.field,\n                    })\n                  );\n                  if(err !== undefined) return err;\n                }\n              }else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if(this.state.quoting === false){\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if(recordDelimiterLength !== 0){\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);\n              if(skipCommentLine){\n                this.info.comment_lines++;\n                // Skip full comment line\n              }else {\n                // Activate records emition if above from_line\n                if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if(errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if(errRecord !== undefined) return errRecord;\n                if(to !== -1 && this.info.records >= to){\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if(this.state.commenting){\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if(commentCount !== 0){\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if(delimiterLength !== 0){\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if(errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if(this.state.commenting === false){\n          if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n            return this.__error(\n              new CsvError$1('CSV_MAX_RECORD_SIZE', [\n                'Max Record Size:',\n                'record exceed the maximum number of tolerated bytes',\n                `of ${max_record_size}`,\n                `at line ${this.info.lines}`,\n              ], this.options, this.__infoField())\n            );\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if(lappend === true && rappend === true){\n          this.state.field.append(chr);\n        }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){\n          return this.__error(\n            new CsvError$1('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n              'Invalid Closing Quote:',\n              'found non trimable byte after quote',\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n        }else {\n          if(lappend === false){\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if(end === true){\n        // Ensure we are not ending in a quoting state\n        if(this.state.quoting === true){\n          const err = this.__error(\n            new CsvError$1('CSV_QUOTE_NOT_CLOSED', [\n              'Quote Not Closed:',\n              `the parsing is finished with an opening quote at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n          if(err !== undefined) return err;\n        }else {\n          // Skip last line if it has no characters\n          if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if(errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if(errRecord !== undefined) return errRecord;\n          }else if(this.state.wasRowDelimiter === true){\n            this.info.empty_lines++;\n          }else if(this.state.commenting === true){\n            this.info.comment_lines++;\n          }\n        }\n      }else {\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function(push){\n      const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;\n      const {enabled, record} = this.state;\n      if(enabled === false){\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if(columns === true){\n        if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if(columns === false && this.info.records === 0){\n        this.state.expectedRecordLength = recordLength;\n      }\n      if(recordLength !== this.state.expectedRecordLength){\n        const err = columns === false ?\n          new CsvError$1('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [\n            'Invalid Record Length:',\n            `expect ${this.state.expectedRecordLength},`,\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          })\n          :\n          new CsvError$1('CSV_RECORD_INCONSISTENT_COLUMNS', [\n            'Invalid Record Length:',\n            `columns length is ${columns.length},`, // rename columns\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          });\n        if(relax_column_count === true ||\n          (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){\n          this.info.invalid_field_length++;\n          this.state.error = err;\n        // Error is undefined with skip_records_with_error\n        }else {\n          const finalErr = this.__error(err);\n          if(finalErr) return finalErr;\n        }\n      }\n      if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord();\n        return;\n      }\n      if(this.state.recordHasError === true){\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if(from === 1 || this.info.records >= from){\n        const {objname} = this.options;\n        // With columns, records are object\n        if(columns !== false){\n          const obj = {};\n          // Transform record array to an object\n          for(let i = 0, l = record.length; i < l; i++){\n            if(columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else {\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        // Without columns, records are array\n        }else {\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: record},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else {\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function(record){\n      const {firstLineToHeaders} = this.state;\n      try{\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if(!Array.isArray(headers)){\n          return this.__error(\n            new CsvError$1('CSV_INVALID_COLUMN_MAPPING', [\n              'Invalid Column Mapping:',\n              'expect an array from column function,',\n              `got ${JSON.stringify(headers)}`\n            ], this.options, this.__infoField(), {\n              headers: headers,\n            })\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      }catch(err){\n        return err;\n      }\n    },\n    __resetRecord: function(){\n      if(this.options.raw === true){\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function(){\n      const {cast, encoding, rtrim, max_record_size} = this.options;\n      const {enabled, wasQuoting} = this.state;\n      // Short circuit for the from_line options\n      if(enabled === false){\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if(rtrim === true && wasQuoting === false){\n        field = field.trimRight();\n      }\n      if(cast === true){\n        const [err, f] = this.__cast(field);\n        if(err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if(max_record_size !== 0 && typeof field === 'string'){\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function(){\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function(record, push){\n      const {on_record} = this.options;\n      if(on_record !== undefined){\n        const info = this.__infoRecord();\n        try{\n          record = on_record.call(null, record, info);\n        }catch(err){\n          return err;\n        }\n        if(record === undefined || record === null){ return; }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function(field){\n      const {columns, relax_column_count} = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){\n        return [undefined, undefined];\n      }\n      if(this.state.castField !== null){\n        try{\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        }catch(err){\n          return [err];\n        }\n      }\n      if(this.__isFloat(field)){\n        return [undefined, parseFloat(field)];\n      }else if(this.options.cast_date !== false){\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function(buf, pos){\n      const isTrim = (buf, pos) => {\n        const {timchars} = this.state;\n        loop1: for(let i = 0; i < timchars.length; i++){\n          const timchar = timchars[i];\n          for(let j = 0; j < timchar.length; j++){\n            if(timchar[j] !== buf[pos+j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function(value){\n      return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){\n      if(sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for(let i = 1; i < sourceLength; i++){\n        if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function(buf, pos, chr){\n      const {delimiter, ignore_last_delimiters} = this.options;\n      if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n        return 0;\n      }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n        return 0;\n      }\n      loop1: for(let i = 0; i < delimiter.length; i++){\n        const del = delimiter[i];\n        if(del[0] === chr){\n          for(let j = 1; j < del.length; j++){\n            if(del[j] !== buf[pos+j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function(chr, buf, pos){\n      const {record_delimiter} = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for(let i = 0; i < recordDelimiterLength; i++){\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if(rd[0] !== chr){\n          continue;\n        }\n        for(let j = 1; j < rdLength; j++){\n          if(rd[j] !== buf[pos+j]){\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function(buf, pos, chr){\n      const {escape} = this.options;\n      if(escape === null) return false;\n      const l = escape.length;\n      if(escape[0] === chr){\n        for(let i = 0; i < l; i++){\n          if(escape[i] !== buf[pos+i]){\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function(buf, pos){\n      const {quote} = this.options;\n      if(quote === null) return false;\n      const l = quote.length;\n      for(let i = 0; i < l; i++){\n        if(quote[i] !== buf[pos+i]){\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function(buf, pos){\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from('\\r\\n', encoding),\n        Buffer.from('\\n', encoding),\n        Buffer.from('\\r', encoding),\n      ];\n      loop: for(let i = 0; i < rds.length; i++){\n        const l = rds[i].length;\n        for(let j = 0; j < l; j++){\n          if(rds[i][j] !== buf[pos + j]){\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function(msg){\n      const {encoding, raw, skip_records_with_error} = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if(skip_records_with_error){\n        this.state.recordHasError = true;\n        if(this.options.on_skip !== undefined){\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      }else {\n        return err;\n      }\n    },\n    __infoDataSet: function(){\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function(){\n      const {columns, raw, encoding} = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function(){\n      const {columns} = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ?\n          (columns.length > this.state.record.length ?\n            columns[this.state.record.length].name :\n            null\n          ) :\n          this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    }\n  };\n};\n\nclass Parser extends stream.Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts, encoding: null});\n    this.api = transform$1(opts);\n    this.api.options.on_skip = (err, chunk) => {\n      this.emit('skip', err, chunk);\n    };\n    // Backward compatibility\n    this.state = this.api.state;\n    this.options = this.api.options;\n    this.info = this.api.info;\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return;\n    }\n    const err = this.api.parse(buf, false, (record) => {\n      this.push(record);\n    }, () => {\n      this.push(null);\n      this.on('end', this.destroy);\n    });\n    if(err !== undefined){\n      this.state.stop = true;\n    }\n    callback(err);\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return;\n    }\n    const err = this.api.parse(undefined, true, (record) => {\n      this.push(record);\n    }, () => {\n      this.push(null);\n      this.on('end', this.destroy);\n    });\n    callback(err);\n  }\n}\n\nconst parse = function(){\n  let data, options, callback;\n  for(const i in arguments){\n    const argument = arguments[i];\n    const type = typeof argument;\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument;\n    }else if(options === undefined && is_object$1(argument)){\n      options = argument;\n    }else if(callback === undefined && type === 'function'){\n      callback = argument;\n    }else {\n      throw new CsvError$1('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ], options || {});\n    }\n  }\n  const parser = new Parser(options);\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function(){\n      let record;\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record);\n        }else {\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function(err){\n      callback(err, undefined, parser.api.__infoDataSet());\n    });\n    parser.on('end', function(){\n      callback(undefined, records, parser.api.__infoDataSet());\n    });\n  }\n  if(data !== undefined){\n    const writer = function(){\n      parser.write(data);\n      parser.end();\n    };\n    // Support Deno, Rollup doesnt provide a shim for setImmediate\n    if(typeof setImmediate === 'function'){\n      setImmediate(writer);\n    }else {\n      setTimeout(writer, 0);\n    }\n  }\n  return parser;\n};\n\nconst Transformer = function(options = {}, handler){\n  this.options = options;\n  if(options.consume === undefined || options.consume === null){\n    this.options.consume = false;\n  }\n  this.options.objectMode = true;\n  if(options.parallel === undefined || options.parallel === null){\n    this.options.parallel = 100;\n  }\n  if(options.params === undefined || options.params === null){\n    options.params = null;\n  }\n  this.handler = handler;\n  stream.Transform.call(this, this.options);\n  this.state = {\n    running: 0,\n    started: 0,\n    finished: 0\n  };\n  return this;\n};\n\nutil.inherits(Transformer, stream.Transform);\n\nTransformer.prototype._transform = function(chunk, encoding, cb){\n  this.state.started++;\n  this.state.running++;\n  if(this.state.running < this.options.parallel){\n    cb();\n    cb = null; // Cancel further callback execution\n  }\n  try {\n    let l = this.handler.length;\n    if(this.options.params !== null){  \n      l--;\n    }\n    if(l === 1){ // sync\n      this.__done(null, [this.handler.call(this, chunk, this.options.params)], cb);\n    }else if(l === 2){ // async\n      const callback = (err, ...chunks) =>\n        this.__done(err, chunks, cb);\n      this.handler.call(this, chunk, callback, this.options.params);\n    }else {\n      throw Error('Invalid handler arguments');\n    }\n    return false;\n  }\n  catch (err) {\n    this.__done(err);\n  }\n};\nTransformer.prototype._flush = function(cb){\n  if(this.state.running === 0){\n    cb();\n  }else {\n    this._ending = function(){\n      cb();\n    };\n  }\n};\nTransformer.prototype.__done = function(err, chunks, cb){\n  this.state.running--;\n  if(err){\n    return this.emit('error', err);\n  }\n  this.state.finished++;\n  for(let chunk of chunks){\n    if (typeof chunk === 'number'){\n      chunk = `${chunk}`;\n    }\n    // We dont push empty string\n    // See https://nodejs.org/api/stream.html#stream_readable_push\n    if(chunk !== undefined && chunk !== null && chunk !== ''){\n      this.push(chunk);\n    }\n  }\n  if(cb){\n    cb();\n  }\n  if(this._ending && this.state.running === 0){\n    this._ending();\n  }\n};\nconst transform = function(){\n  let options = {};\n  let callback, handler, records;\n  for(let i = 0; i< arguments.length; i++){\n    const argument = arguments[i];\n    let type = typeof argument;\n    if(argument === null){\n      type = 'null';\n    }else if(type === 'object' && Array.isArray(argument)){\n      type = 'array';\n    }\n    if(type === 'array'){\n      records = argument;\n    }else if(type === 'object'){\n      options = {...argument};\n    }else if(type === 'function'){\n      if (handler && i === arguments.length - 1) {\n        callback = argument;\n      } else {\n        handler = argument;\n      }\n    }else if(type !== 'null'){\n      throw new Error(`Invalid Arguments: got ${JSON.stringify(argument)} at position ${i}`);\n    }\n  }\n  const transformer = new Transformer(options, handler);\n  let error = false;\n  if (records) {\n    const writer = function(){\n      for(const record of records){\n        if(error) break;\n        transformer.write(record);\n      }\n      transformer.end();\n    };\n    // Support Deno, Rollup doesnt provide a shim for setImmediate\n    if(typeof setImmediate === 'function'){\n      setImmediate(writer);\n    }else {\n      setTimeout(writer, 0);\n    }\n  }\n  if(callback || options.consume) {\n    const result = [];\n    transformer.on('readable', function(){\n      let record; while((record = transformer.read()) !== null){\n        if(callback){\n          result.push(record);\n        }\n      }\n    });\n    transformer.on('error', function(err){\n      error = true;\n      if (callback) callback(err);\n    });\n    transformer.on('end', function(){\n      if (callback && !error) callback(null, result);\n    });\n  }\n  return transformer;\n};\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ');\n    super(message);\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nconst is_object = function(obj){\n  return typeof obj === 'object' && obj !== null && ! Array.isArray(obj);\n};\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = '.'.charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n  , 'g');\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\nconst getTag = function(value){\n  return Object.prototype.toString.call(value);\n};\nconst isSymbol = function(value){\n  const type = typeof value;\n  return type === 'symbol' || (type === 'object' && value && getTag(value) === '[object Symbol]');\n};\nconst isKey = function(value, object){\n  if(Array.isArray(value)){\n    return false;\n  }\n  const type = typeof value;\n  if(type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)){\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n};\nconst stringToPath = function(string){\n  const result = [];\n  if(string.charCodeAt(0) === charCodeOfDot){\n    result.push('');\n  }\n  string.replace(rePropName, function(match, expression, quote, subString){\n    let key = match;\n    if(quote){\n      key = subString.replace(reEscapeChar, '$1');\n    }else if(expression){\n      key = expression.trim();\n    }\n    result.push(key);\n  });\n  return result;\n};\nconst castPath = function(value, object){\n  if(Array.isArray(value)){\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\nconst toKey = function(value){\n  if(typeof value === 'string' || isSymbol(value))\n    return value;\n  const result = `${value}`;\n  // eslint-disable-next-line\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n};\nconst get = function(object, path){\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n  while(object != null && index < length){\n    object = object[toKey(path[index++])];\n  }\n  return (index && index === length) ? object : undefined;\n};\n\nconst normalize_columns = function(columns){\n  if(columns === undefined || columns === null){\n    return [undefined, undefined];\n  }\n  if(typeof columns !== 'object'){\n    return [Error('Invalid option \"columns\": expect an array or an object')];\n  }\n  if(!Array.isArray(columns)){\n    const newcolumns = [];\n    for(const k in columns){\n      newcolumns.push({\n        key: k,\n        header: columns[k]\n      });\n    }\n    columns = newcolumns;\n  }else {\n    const newcolumns = [];\n    for(const column of columns){\n      if(typeof column === 'string'){\n        newcolumns.push({\n          key: column,\n          header: column\n        });\n      }else if(typeof column === 'object' && column !== null && !Array.isArray(column)){\n        if(!column.key){\n          return [Error('Invalid column definition: property \"key\" is required')];\n        }\n        if(column.header === undefined){\n          column.header = column.key;\n        }\n        newcolumns.push(column);\n      }else {\n        return [Error('Invalid column definition: expect a string or an object')];\n      }\n    }\n    columns = newcolumns;\n  }\n  return [undefined, columns];\n};\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase();\n  });\n};\n\nconst normalize_options = function(opts) {\n  const options = {};\n  // Merge with user options\n  for(const opt in opts){\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `bom`\n  if(options.bom === undefined || options.bom === null || options.bom === false){\n    options.bom = false;\n  }else if(options.bom !== true){\n    return [new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', [\n      'option `bom` is optional and must be a boolean value,',\n      `got ${JSON.stringify(options.bom)}`\n    ])];\n  }\n  // Normalize option `delimiter`\n  if(options.delimiter === undefined || options.delimiter === null){\n    options.delimiter = ',';\n  }else if(Buffer.isBuffer(options.delimiter)){\n    options.delimiter = options.delimiter.toString();\n  }else if(typeof options.delimiter !== 'string'){\n    return [new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', [\n      'option `delimiter` must be a buffer or a string,',\n      `got ${JSON.stringify(options.delimiter)}`\n    ])];\n  }\n  // Normalize option `quote`\n  if(options.quote === undefined || options.quote === null){\n    options.quote = '\"';\n  }else if(options.quote === true){\n    options.quote = '\"';\n  }else if(options.quote === false){\n    options.quote = '';\n  }else if (Buffer.isBuffer(options.quote)){\n    options.quote = options.quote.toString();\n  }else if(typeof options.quote !== 'string'){\n    return [new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', [\n      'option `quote` must be a boolean, a buffer or a string,',\n      `got ${JSON.stringify(options.quote)}`\n    ])];\n  }\n  // Normalize option `quoted`\n  if(options.quoted === undefined || options.quoted === null){\n    options.quoted = false;\n  }\n  // Normalize option `escape_formulas`\n  if(options.escape_formulas === undefined || options.escape_formulas === null){\n    options.escape_formulas = false;\n  }else if(typeof options.escape_formulas !== 'boolean'){\n    return [new CsvError('CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE', [\n      'option `escape_formulas` must be a boolean,',\n      `got ${JSON.stringify(options.escape_formulas)}`\n    ])];\n  }\n  // Normalize option `quoted_empty`\n  if(options.quoted_empty === undefined || options.quoted_empty === null){\n    options.quoted_empty = undefined;\n  }\n  // Normalize option `quoted_match`\n  if(options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false){\n    options.quoted_match = null;\n  }else if(!Array.isArray(options.quoted_match)){\n    options.quoted_match = [options.quoted_match];\n  }\n  if(options.quoted_match){\n    for(const quoted_match of options.quoted_match){\n      const isString = typeof quoted_match === 'string';\n      const isRegExp = quoted_match instanceof RegExp;\n      if(!isString && !isRegExp){\n        return [Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)];\n      }\n    }\n  }\n  // Normalize option `quoted_string`\n  if(options.quoted_string === undefined || options.quoted_string === null){\n    options.quoted_string = false;\n  }\n  // Normalize option `eof`\n  if(options.eof === undefined || options.eof === null){\n    options.eof = true;\n  }\n  // Normalize option `escape`\n  if(options.escape === undefined || options.escape === null){\n    options.escape = '\"';\n  }else if(Buffer.isBuffer(options.escape)){\n    options.escape = options.escape.toString();\n  }else if(typeof options.escape !== 'string'){\n    return [Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)];\n  }\n  if (options.escape.length > 1){\n    return [Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)];\n  }\n  // Normalize option `header`\n  if(options.header === undefined || options.header === null){\n    options.header = false;\n  }\n  // Normalize option `columns`\n  const [errColumns, columns] = normalize_columns(options.columns);\n  if(errColumns !== undefined) return [errColumns];\n  options.columns = columns;\n  // Normalize option `quoted`\n  if(options.quoted === undefined || options.quoted === null){\n    options.quoted = false;\n  }\n  // Normalize option `cast`\n  if(options.cast === undefined || options.cast === null){\n    options.cast = {};\n  }\n  // Normalize option cast.bigint\n  if(options.cast.bigint === undefined || options.cast.bigint === null){\n    // Cast boolean to string by default\n    options.cast.bigint = value => '' + value;\n  }\n  // Normalize option cast.boolean\n  if(options.cast.boolean === undefined || options.cast.boolean === null){\n    // Cast boolean to string by default\n    options.cast.boolean = value => value ? '1' : '';\n  }\n  // Normalize option cast.date\n  if(options.cast.date === undefined || options.cast.date === null){\n    // Cast date to timestamp string by default\n    options.cast.date = value => '' + value.getTime();\n  }\n  // Normalize option cast.number\n  if(options.cast.number === undefined || options.cast.number === null){\n    // Cast number to string using native casting by default\n    options.cast.number = value => '' + value;\n  }\n  // Normalize option cast.object\n  if(options.cast.object === undefined || options.cast.object === null){\n    // Stringify object as JSON by default\n    options.cast.object = value => JSON.stringify(value);\n  }\n  // Normalize option cast.string\n  if(options.cast.string === undefined || options.cast.string === null){\n    // Leave string untouched\n    options.cast.string = function(value){return value;};\n  }\n  // Normalize option `on_record`\n  if(options.on_record !== undefined && typeof options.on_record !== 'function'){\n    return [Error(`Invalid Option: \"on_record\" must be a function.`)];\n  }\n  // Normalize option `record_delimiter`\n  if(options.record_delimiter === undefined || options.record_delimiter === null){\n    options.record_delimiter = '\\n';\n  }else if(Buffer.isBuffer(options.record_delimiter)){\n    options.record_delimiter = options.record_delimiter.toString();\n  }else if(typeof options.record_delimiter !== 'string'){\n    return [Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)];\n  }\n  switch(options.record_delimiter){\n  case 'auto':\n    options.record_delimiter = null;\n    break;\n  case 'unix':\n    options.record_delimiter = \"\\n\";\n    break;\n  case 'mac':\n    options.record_delimiter = \"\\r\";\n    break;\n  case 'windows':\n    options.record_delimiter = \"\\r\\n\";\n    break;\n  case 'ascii':\n    options.record_delimiter = \"\\u001e\";\n    break;\n  case 'unicode':\n    options.record_delimiter = \"\\u2028\";\n    break;\n  }\n  return [undefined, options];\n};\n\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nconst stringifier = function(options, state, info){\n  return {\n    options: options,\n    state: state,\n    info: info,\n    __transform: function(chunk, push){\n      // Chunk validation\n      if(!Array.isArray(chunk) && typeof chunk !== 'object'){\n        return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);\n      }\n      // Detect columns from the first record\n      if(this.info.records === 0){\n        if(Array.isArray(chunk)){\n          if(this.options.header === true && this.options.columns === undefined){\n            return Error('Undiscoverable Columns: header option requires column option or object records');\n          }\n        }else if(this.options.columns === undefined){\n          const [err, columns] = normalize_columns(Object.keys(chunk));\n          if(err) return;\n          this.options.columns = columns;\n        }\n      }\n      // Emit the header\n      if(this.info.records === 0){\n        this.bom(push);\n        const err = this.headers(push);\n        if(err) return err;\n      }\n      // Emit and stringify the record if an object or an array\n      try{\n        // this.emit('record', chunk, this.info.records);\n        if(this.options.on_record){\n          this.options.on_record(chunk, this.info.records);\n        }\n      }catch(err){\n        return err;\n      }\n      // Convert the record into a string\n      let err, chunk_string;\n      if(this.options.eof){\n        [err, chunk_string] = this.stringify(chunk);\n        if(err) return err;\n        if(chunk_string === undefined){\n          return;\n        }else {\n          chunk_string = chunk_string + this.options.record_delimiter;\n        }\n      }else {\n        [err, chunk_string] = this.stringify(chunk);\n        if(err) return err;\n        if(chunk_string === undefined){\n          return;\n        }else {\n          if(this.options.header || this.info.records){\n            chunk_string = this.options.record_delimiter + chunk_string;\n          }\n        }\n      }\n      // Emit the csv\n      this.info.records++;\n      push(chunk_string);\n    },\n    stringify: function(chunk, chunkIsHeader=false){\n      if(typeof chunk !== 'object'){\n        return [undefined, chunk];\n      }\n      const {columns} = this.options;\n      const record = [];\n      // Record is an array\n      if(Array.isArray(chunk)){\n        // We are getting an array but the user has specified output columns. In\n        // this case, we respect the columns indexes\n        if(columns){\n          chunk.splice(columns.length);\n        }\n        // Cast record elements\n        for(let i=0; i<chunk.length; i++){\n          const field = chunk[i];\n          const [err, value] = this.__cast(field, {\n            index: i, column: i, records: this.info.records, header: chunkIsHeader\n          });\n          if(err) return [err];\n          record[i] = [value, field];\n        }\n      // Record is a literal object\n      // `columns` is always defined: it is either provided or discovered.\n      }else {\n        for(let i=0; i<columns.length; i++){\n          const field = get(chunk, columns[i].key);\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          });\n          if(err) return [err];\n          record[i] = [value, field];\n        }\n      }\n      let csvrecord = '';\n      for(let i=0; i<record.length; i++){\n        let options, err;\n        // eslint-disable-next-line\n        let [value, field] = record[i];\n        if(typeof value === \"string\"){\n          options = this.options;\n        }else if(is_object(value)){\n          options = value;\n          value = options.value;\n          delete options.value;\n          if(typeof value !== \"string\" && value !== undefined && value !== null){\n            if(err) return [Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)];\n          }\n          options = {...this.options, ...options};\n          [err, options] = normalize_options(options);\n          if(err !== undefined){\n            return [err];\n          }\n        }else if(value === undefined || value === null){\n          options = this.options;\n        }else {\n          return [Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)];\n        }\n        const {delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas} = options;\n        if('' === value && '' === field){\n          let quotedMatch = quoted_match && quoted_match.filter(quoted_match => {\n            if(typeof quoted_match === 'string'){\n              return value.indexOf(quoted_match) !== -1;\n            }else {\n              return quoted_match.test(value);\n            }\n          });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          const shouldQuote = quotedMatch || true === quoted_empty ||\n            (true === quoted_string && false !== quoted_empty);\n          if(shouldQuote === true){\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        }else if(value){\n          if(typeof value !== 'string'){\n            return [Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)];\n          }\n          const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n          const containsQuote = (quote !== '') && value.indexOf(quote) >= 0;\n          const containsEscape = value.indexOf(escape) >= 0 && (escape !== quote);\n          const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n          const quotedString = quoted_string && typeof field === 'string';\n          let quotedMatch = quoted_match && quoted_match.filter(quoted_match => {\n            if(typeof quoted_match === 'string'){\n              return value.indexOf(quoted_match) !== -1;\n            }else {\n              return quoted_match.test(value);\n            }\n          });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          if (escape_formulas && ['=', '+', '-', '@', '\\t', '\\r'].includes(value[0])) {\n            value = `'${value}`;\n          }\n          const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n          if(shouldQuote === true && containsEscape === true){\n            const regexp = escape === '\\\\'\n              ? new RegExp(escape + escape, 'g')\n              : new RegExp(escape, 'g');\n            value = value.replace(regexp, escape + escape);\n          }\n          if(containsQuote === true){\n            const regexp = new RegExp(quote,'g');\n            value = value.replace(regexp, escape + quote);\n          }\n          if(shouldQuote === true){\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        }else if(quoted_empty === true || (field === '' && quoted_string === true && quoted_empty !== false)){\n          csvrecord += quote + quote;\n        }\n        if(i !== record.length - 1){\n          csvrecord += delimiter;\n        }\n      }\n      return [undefined, csvrecord];\n    },\n    bom: function(push){\n      if(this.options.bom !== true){\n        return;\n      }\n      push(bom_utf8);\n    },\n    headers: function(push){\n      if(this.options.header === false){\n        return;\n      }\n      if(this.options.columns === undefined){\n        return;\n      }\n      let err;\n      let headers = this.options.columns.map(column => column.header);\n      if(this.options.eof){\n        [err, headers] = this.stringify(headers, true);\n        headers += this.options.record_delimiter;\n      }else {\n        [err, headers] = this.stringify(headers);\n      }\n      if(err) return err;\n      push(headers);\n    },\n    __cast: function(value, context){\n      const type = typeof value;\n      try{\n        if(type === 'string'){ // Fine for 99% of the cases\n          return [undefined, this.options.cast.string(value, context)];\n        }else if(type === 'bigint'){\n          return [undefined, this.options.cast.bigint(value, context)];\n        }else if(type === 'number'){\n          return [undefined, this.options.cast.number(value, context)];\n        }else if(type === 'boolean'){\n          return [undefined, this.options.cast.boolean(value, context)];\n        }else if(value instanceof Date){\n          return [undefined, this.options.cast.date(value, context)];\n        }else if(type === 'object' && value !== null){\n          return [undefined, this.options.cast.object(value, context)];\n        }else {\n          return [undefined, value, value];\n        }\n      }catch(err){\n        return [err];\n      }\n    }\n  };\n};\n\nclass Stringifier extends stream.Transform {\n  constructor(opts = {}){\n    super({...{writableObjectMode: true}, ...opts});\n    const [err, options] = normalize_options(opts);\n    if(err !== undefined) throw err;\n    // Expose options\n    this.options = options;\n    // Internal state\n    this.state = {\n      stop: false\n    };\n    // Information\n    this.info = {\n      records: 0\n    };\n    this.api = stringifier(this.options, this.state, this.info);\n    this.api.options.on_record = (...args) => {\n      this.emit('record', ...args);\n    };\n  }\n  _transform(chunk, encoding, callback){\n    if(this.state.stop === true){\n      return;\n    }\n    const err = this.api.__transform(chunk, this.push.bind(this));\n    if(err !== undefined){\n      this.state.stop = true;\n    }\n    callback(err);\n  }\n  _flush(callback){\n    if(this.state.stop === true){\n      // Note, Node.js 12 call flush even after an error, we must prevent\n      // `callback` from being called in flush without any error.\n      return;\n    }\n    if(this.info.records === 0){\n      this.api.bom(this.push.bind(this));\n      const err = this.api.headers(this.push.bind(this));\n      if(err) callback(err);\n    }\n    callback();\n  }\n}\n\nconst stringify = function(){\n  let data, options, callback;\n  for(const i in arguments){\n    const argument = arguments[i];\n    const type = typeof argument;\n    if(data === undefined && (Array.isArray(argument))){\n      data = argument;\n    }else if(options === undefined && is_object(argument)){\n      options = argument;\n    }else if(callback === undefined && type === 'function'){\n      callback = argument;\n    }else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ]);\n    }\n  }\n  const stringifier = new Stringifier(options);\n  if(callback){\n    const chunks = [];\n    stringifier.on('readable', function(){\n      let chunk;\n      while((chunk = this.read()) !== null){\n        chunks.push(chunk);\n      }\n    });\n    stringifier.on('error', function(err){\n      callback(err);\n    });\n    stringifier.on('end', function(){\n      callback(undefined, chunks.join(''));\n    });\n  }\n  if(data !== undefined){\n    const writer = function(){\n      for(const record of data){\n        stringifier.write(record);\n      }\n      stringifier.end();\n    };\n    // Support Deno, Rollup doesnt provide a shim for setImmediate\n    if(typeof setImmediate === 'function'){\n      setImmediate(writer);\n    }else {\n      setTimeout(writer, 0);\n    }\n  }\n  return stringifier;\n};\n\nexports.generate = generate;\nexports.parse = parse;\nexports.stringify = stringify;\nexports.transform = transform;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3N2L2Rpc3QvY2pzL2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2Nzdi9kaXN0L2Nqcy9pbmRleC5janM/ZjU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBpbml0X3N0YXRlJDEgPSAob3B0aW9ucykgPT4ge1xuICAvLyBTdGF0ZVxuICByZXR1cm4ge1xuICAgIHN0YXJ0X3RpbWU6IG9wdGlvbnMuZHVyYXRpb24gPyBEYXRlLm5vdygpIDogbnVsbCxcbiAgICBmaXhlZF9zaXplX2J1ZmZlcjogJycsXG4gICAgY291bnRfd3JpdHRlbjogMCxcbiAgICBjb3VudF9jcmVhdGVkOiAwLFxuICB9O1xufTtcblxuLy8gR2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB3aXRoIDIgZGVjaW1hbHMuIFRoZSBmdW5jdGlvbiBpcyBpZGVtcG90ZW50IGlmIGl0IGRldGVjdCB0aGUgXCJzZWVkXCIgb3B0aW9uLlxuY29uc3QgcmFuZG9tID0gZnVuY3Rpb24ob3B0aW9ucz17fSl7XG4gIGlmKG9wdGlvbnMuc2VlZCl7XG4gICAgcmV0dXJuIG9wdGlvbnMuc2VlZCA9IG9wdGlvbnMuc2VlZCAqIE1hdGguUEkgKiAxMDAgJSAxMDAgLyAxMDA7XG4gIH1lbHNlIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxufTtcblxuY29uc3QgdHlwZXMgPSB7XG4gIC8vIEdlbmVyYXRlIGFuIEFTQ0lJIHZhbHVlLlxuICBhc2NpaTogZnVuY3Rpb24oe29wdGlvbnN9KXtcbiAgICBjb25zdCBjb2x1bW4gPSBbXTtcbiAgICBjb25zdCBuYl9jaGFycyA9IE1hdGguY2VpbChyYW5kb20ob3B0aW9ucykgKiBvcHRpb25zLm1heFdvcmRMZW5ndGgpO1xuICAgIGZvcihsZXQgaT0wOyBpPG5iX2NoYXJzOyBpKyspe1xuICAgICAgY29uc3QgY2hhciA9IE1hdGguZmxvb3IocmFuZG9tKG9wdGlvbnMpICogMzIpO1xuICAgICAgY29sdW1uLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyICsgKGNoYXIgPCAxNiA/IDY1IDogOTcgLSAxNikpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbHVtbi5qb2luKCcnKTtcbiAgfSxcbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciB2YWx1ZS5cbiAgaW50OiBmdW5jdGlvbih7b3B0aW9uc30pe1xuICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmRvbShvcHRpb25zKSAqIE1hdGgucG93KDIsIDUyKSk7XG4gIH0sXG4gIC8vIEdlbmVyYXRlIGFuIGJvb2xlYW4gdmFsdWUuXG4gIGJvb2w6IGZ1bmN0aW9uKHtvcHRpb25zfSl7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tKG9wdGlvbnMpICogMik7XG4gIH1cbn07XG5cbmNvbnN0IGNhbWVsaXplID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9fKFthLXpdKS9naSwgZnVuY3Rpb24oXywgbWF0Y2gpe1xuICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9vcHRpb25zJDIgPSAob3B0cykgPT4ge1xuICAvLyBDb252ZXJ0IFN0cmVhbSBSZWFkYWJsZSBvcHRpb25zIGlmIHVuZGVyc2NvcmVkXG4gIGlmKG9wdHMuaGlnaF93YXRlcl9tYXJrKXtcbiAgICBvcHRzLmhpZ2hXYXRlck1hcmsgPSBvcHRzLmhpZ2hfd2F0ZXJfbWFyaztcbiAgfVxuICBpZihvcHRzLm9iamVjdF9tb2RlKXtcbiAgICBvcHRzLm9iamVjdE1vZGUgPSBvcHRzLm9iamVjdF9tb2RlO1xuICB9XG4gIC8vIENsb25lIGFuZCBjYW1lbGl6ZSBvcHRpb25zXG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgZm9yKGNvbnN0IGsgaW4gb3B0cyl7XG4gICAgb3B0aW9uc1tjYW1lbGl6ZShrKV0gPSBvcHRzW2tdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb25zXG4gIGNvbnN0IGRmdCA9IHtcbiAgICBjb2x1bW5zOiA4LFxuICAgIGRlbGltaXRlcjogJywnLFxuICAgIGR1cmF0aW9uOiBudWxsLFxuICAgIGVuY29kaW5nOiBudWxsLFxuICAgIGVuZDogbnVsbCxcbiAgICBlb2Y6IGZhbHNlLFxuICAgIGZpeGVkU2l6ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiAtMSxcbiAgICBtYXhXb3JkTGVuZ3RoOiAxNixcbiAgICByb3dEZWxpbWl0ZXI6ICdcXG4nLFxuICAgIHNlZWQ6IGZhbHNlLFxuICAgIHNsZWVwOiAwLFxuICB9O1xuICBmb3IoY29uc3QgayBpbiBkZnQpe1xuICAgIGlmKG9wdGlvbnNba10gPT09IHVuZGVmaW5lZCl7XG4gICAgICBvcHRpb25zW2tdID0gZGZ0W2tdO1xuICAgIH1cbiAgfVxuICAvLyBEZWZhdWx0IHZhbHVlc1xuICBpZihvcHRpb25zLmVvZiA9PT0gdHJ1ZSl7XG4gICAgb3B0aW9ucy5lb2YgPSBvcHRpb25zLnJvd0RlbGltaXRlcjtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucy5jb2x1bW5zID09PSAnbnVtYmVyJyl7XG4gICAgb3B0aW9ucy5jb2x1bW5zID0gbmV3IEFycmF5KG9wdGlvbnMuY29sdW1ucyk7XG4gIH1cbiAgY29uc3QgYWNjZXB0ZWRfaGVhZGVyX3R5cGVzID0gT2JqZWN0LmtleXModHlwZXMpLmZpbHRlcigodCkgPT4gKCFbJ3N1cGVyXycsICdjYW1lbGl6ZSddLmluY2x1ZGVzKHQpKSk7XG4gIGZvcihsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmNvbHVtbnMubGVuZ3RoOyBpKyspe1xuICAgIGNvbnN0IHYgPSBvcHRpb25zLmNvbHVtbnNbaV0gfHwgJ2FzY2lpJztcbiAgICBpZih0eXBlb2YgdiA9PT0gJ3N0cmluZycpe1xuICAgICAgaWYoIWFjY2VwdGVkX2hlYWRlcl90eXBlcy5pbmNsdWRlcyh2KSl7XG4gICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGNvbHVtbiB0eXBlOiBnb3QgXCIke3Z9XCIsIGRlZmF1bHQgdmFsdWVzIGFyZSAke0pTT04uc3RyaW5naWZ5KGFjY2VwdGVkX2hlYWRlcl90eXBlcyl9YCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmNvbHVtbnNbaV0gPSB0eXBlc1t2XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5jb25zdCByZWFkID0gKG9wdGlvbnMsIHN0YXRlLCBzaXplLCBwdXNoLCBjbG9zZSkgPT4ge1xuICAvLyBBbHJlYWR5IHN0YXJ0ZWRcbiAgY29uc3QgZGF0YSA9IFtdO1xuICBsZXQgbGVuZ3RoID0gc3RhdGUuZml4ZWRfc2l6ZV9idWZmZXIubGVuZ3RoO1xuICBpZihsZW5ndGggIT09IDApe1xuICAgIGRhdGEucHVzaChzdGF0ZS5maXhlZF9zaXplX2J1ZmZlcik7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHdoaWxlKHRydWUpe1xuICAgIC8vIFRpbWUgZm9yIHNvbWUgcmVzdDogZmx1c2ggZmlyc3QgYW5kIHN0b3AgbGF0ZXJcbiAgICBpZigoc3RhdGUuY291bnRfY3JlYXRlZCA9PT0gb3B0aW9ucy5sZW5ndGgpIHx8IChvcHRpb25zLmVuZCAmJiBEYXRlLm5vdygpID4gb3B0aW9ucy5lbmQpIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIERhdGUubm93KCkgPiBzdGF0ZS5zdGFydF90aW1lICsgb3B0aW9ucy5kdXJhdGlvbikpe1xuICAgICAgLy8gRmx1c2hcbiAgICAgIGlmKGRhdGEubGVuZ3RoKXtcbiAgICAgICAgaWYob3B0aW9ucy5vYmplY3RNb2RlKXtcbiAgICAgICAgICBmb3IoY29uc3QgcmVjb3JkIG9mIGRhdGEpe1xuICAgICAgICAgICAgcHVzaChyZWNvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIHB1c2goZGF0YS5qb2luKCcnKSArIChvcHRpb25zLmVvZiA/IG9wdGlvbnMuZW9mIDogJycpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5lbmQgPSB0cnVlO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIHJlY29yZFxuICAgIGxldCByZWNvcmQgPSBbXTtcbiAgICBsZXQgcmVjb3JkTGVuZ3RoO1xuICAgIGZvcihjb25zdCBmbiBvZiBvcHRpb25zLmNvbHVtbnMpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm4oe29wdGlvbnM6IG9wdGlvbnMsIHN0YXRlOiBzdGF0ZX0pO1xuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiByZXN1bHQ7XG4gICAgICBpZihyZXN1bHQgIT09IG51bGwgJiYgdHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ251bWJlcicpe1xuICAgICAgICByZXR1cm4gRXJyb3IoW1xuICAgICAgICAgICdJTlZBTElEX1ZBTFVFOicsXG4gICAgICAgICAgJ3ZhbHVlcyByZXR1cm5lZCBieSBjb2x1bW4gZnVuY3Rpb24gbXVzdCBiZScsXG4gICAgICAgICAgJ2Egc3RyaW5nLCBhIG51bWJlciBvciBudWxsLCcsXG4gICAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YFxuICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICByZWNvcmQucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBPYnRhaW4gcmVjb3JkIGxlbmd0aFxuICAgIGlmKG9wdGlvbnMub2JqZWN0TW9kZSl7XG4gICAgICByZWNvcmRMZW5ndGggPSAwO1xuICAgICAgLy8gcmVjb3JkTGVuZ3RoIGlzIGN1cnJlbnRseSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgIC8vIFRoaXMgaXMgd3JvbmcgYW5kIHNoYWxsIGVxdWFsIHRvIDEgcmVjb3JkIG9ubHlcbiAgICAgIGZvcihjb25zdCBjb2x1bW4gb2YgcmVjb3JkKXtcbiAgICAgICAgcmVjb3JkTGVuZ3RoICs9IGNvbHVtbi5sZW5ndGg7XG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgLy8gU3RyaW5naWZ5IHRoZSByZWNvcmRcbiAgICAgIHJlY29yZCA9IChzdGF0ZS5jb3VudF9jcmVhdGVkID09PSAwID8gJycgOiBvcHRpb25zLnJvd0RlbGltaXRlcikrcmVjb3JkLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgICAgcmVjb3JkTGVuZ3RoID0gcmVjb3JkLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGUuY291bnRfY3JlYXRlZCsrO1xuICAgIGlmKGxlbmd0aCArIHJlY29yZExlbmd0aCA+IHNpemUpe1xuICAgICAgaWYob3B0aW9ucy5vYmplY3RNb2RlKXtcbiAgICAgICAgZGF0YS5wdXNoKHJlY29yZCk7XG4gICAgICAgIGZvcihjb25zdCByZWNvcmQgb2YgZGF0YSl7XG4gICAgICAgICAgcHVzaChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGlmKG9wdGlvbnMuZml4ZWRTaXplKXtcbiAgICAgICAgICBzdGF0ZS5maXhlZF9zaXplX2J1ZmZlciA9IHJlY29yZC5zdWJzdHIoc2l6ZSAtIGxlbmd0aCk7XG4gICAgICAgICAgZGF0YS5wdXNoKHJlY29yZC5zdWJzdHIoMCwgc2l6ZSAtIGxlbmd0aCkpO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgZGF0YS5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChkYXRhLmpvaW4oJycpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGVuZ3RoICs9IHJlY29yZExlbmd0aDtcbiAgICBkYXRhLnB1c2gocmVjb3JkKTtcbiAgfVxufTtcblxuY29uc3QgR2VuZXJhdG9yID0gZnVuY3Rpb24ob3B0aW9ucyA9IHt9KXtcbiAgdGhpcy5vcHRpb25zID0gbm9ybWFsaXplX29wdGlvbnMkMihvcHRpb25zKTtcbiAgLy8gQ2FsbCBwYXJlbnQgY29uc3RydWN0b3JcbiAgc3RyZWFtLlJlYWRhYmxlLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgdGhpcy5zdGF0ZSA9IGluaXRfc3RhdGUkMSh0aGlzLm9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG51dGlsLmluaGVyaXRzKEdlbmVyYXRvciwgc3RyZWFtLlJlYWRhYmxlKTtcblxuLy8gU3RvcCB0aGUgZ2VuZXJhdGlvbi5cbkdlbmVyYXRvci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5wdXNoKG51bGwpO1xufTtcbi8vIFB1dCBuZXcgZGF0YSBpbnRvIHRoZSByZWFkIHF1ZXVlLlxuR2VuZXJhdG9yLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpe1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3QgZXJyID0gcmVhZCh0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHNpemUsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgc2VsZi5fX3B1c2goY2h1bmspO1xuICB9LCBmdW5jdGlvbigpe1xuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG4gIGlmKGVycil7XG4gICAgdGhpcy5kZXN0cm95KGVycik7XG4gIH1cbn07XG4vLyBQdXQgbmV3IGRhdGEgaW50byB0aGUgcmVhZCBxdWV1ZS5cbkdlbmVyYXRvci5wcm90b3R5cGUuX19wdXNoID0gZnVuY3Rpb24ocmVjb3JkKXtcbiAgLy8gY29uc29sZS5sb2coJ3B1c2gnLCByZWNvcmQpXG4gIGNvbnN0IHB1c2ggPSAoKSA9PiB7XG4gICAgdGhpcy5zdGF0ZS5jb3VudF93cml0dGVuKys7XG4gICAgdGhpcy5wdXNoKHJlY29yZCk7XG4gICAgaWYodGhpcy5zdGF0ZS5lbmQgPT09IHRydWUpe1xuICAgICAgcmV0dXJuIHRoaXMucHVzaChudWxsKTtcbiAgICB9XG4gIH07XG4gIHRoaXMub3B0aW9ucy5zbGVlcCA+IDAgPyBzZXRUaW1lb3V0KHB1c2gsIHRoaXMub3B0aW9ucy5zbGVlcCkgOiBwdXNoKCk7XG59O1xuXG5jb25zdCBnZW5lcmF0ZSA9IGZ1bmN0aW9uKCl7XG4gIGxldCBvcHRpb25zO1xuICBsZXQgY2FsbGJhY2s7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpe1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gIH1lbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpe1xuICAgIGlmKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpe1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgfWVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICB9XG4gIH1lbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDApe1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgR2VuZXJhdG9yKG9wdGlvbnMpO1xuICBpZihjYWxsYmFjayl7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGdlbmVyYXRvci5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpe1xuICAgICAgbGV0IGQ7IHdoaWxlKChkID0gZ2VuZXJhdG9yLnJlYWQoKSkgIT09IG51bGwpe1xuICAgICAgICBkYXRhLnB1c2goZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZ2VuZXJhdG9yLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICBnZW5lcmF0b3Iub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZihnZW5lcmF0b3Iub3B0aW9ucy5vYmplY3RNb2RlKXtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGlmKGdlbmVyYXRvci5vcHRpb25zLmVuY29kaW5nKXtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhLmpvaW4oJycpKTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGdlbmVyYXRvcjtcbn07XG5cbmNvbnN0IGlzX29iamVjdCQxID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKSk7XG59O1xuXG5sZXQgQ3N2RXJyb3IkMSA9IGNsYXNzIENzdkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBvcHRpb25zLCAuLi5jb250ZXh0cykge1xuICAgIGlmKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIG1lc3NhZ2UgPSBtZXNzYWdlLmpvaW4oJyAnKS50cmltKCk7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IHVuZGVmaW5lZCl7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3ZFcnJvciQxKTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBmb3IoY29uc3QgY29udGV4dCBvZiBjb250ZXh0cyl7XG4gICAgICBmb3IoY29uc3Qga2V5IGluIGNvbnRleHQpe1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgdGhpc1trZXldID0gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKG9wdGlvbnMuZW5jb2RpbmcpIDogdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY29uc3Qgbm9ybWFsaXplX2NvbHVtbnNfYXJyYXkgPSBmdW5jdGlvbihjb2x1bW5zKXtcbiAgY29uc3Qgbm9ybWFsaXplZENvbHVtbnMgPSBbXTtcbiAgZm9yKGxldCBpID0gMCwgbCA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgIGlmKGNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbiA9PT0gbnVsbCB8fCBjb2x1bW4gPT09IGZhbHNlKXtcbiAgICAgIG5vcm1hbGl6ZWRDb2x1bW5zW2ldID0geyBkaXNhYmxlZDogdHJ1ZSB9O1xuICAgIH1lbHNlIGlmKHR5cGVvZiBjb2x1bW4gPT09ICdzdHJpbmcnKXtcbiAgICAgIG5vcm1hbGl6ZWRDb2x1bW5zW2ldID0geyBuYW1lOiBjb2x1bW4gfTtcbiAgICB9ZWxzZSBpZihpc19vYmplY3QkMShjb2x1bW4pKXtcbiAgICAgIGlmKHR5cGVvZiBjb2x1bW4ubmFtZSAhPT0gJ3N0cmluZycpe1xuICAgICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX09QVElPTl9DT0xVTU5TX01JU1NJTkdfTkFNRScsIFtcbiAgICAgICAgICAnT3B0aW9uIGNvbHVtbnMgbWlzc2luZyBuYW1lOicsXG4gICAgICAgICAgYHByb3BlcnR5IFwibmFtZVwiIGlzIHJlcXVpcmVkIGF0IHBvc2l0aW9uICR7aX1gLFxuICAgICAgICAgICd3aGVuIGNvbHVtbiBpcyBhbiBvYmplY3QgbGl0ZXJhbCdcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICBub3JtYWxpemVkQ29sdW1uc1tpXSA9IGNvbHVtbjtcbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfQ09MVU1OX0RFRklOSVRJT04nLCBbXG4gICAgICAgICdJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOicsXG4gICAgICAgICdleHBlY3QgYSBzdHJpbmcgb3IgYSBsaXRlcmFsIG9iamVjdCwnLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkoY29sdW1uKX0gYXQgcG9zaXRpb24gJHtpfWBcbiAgICAgIF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZENvbHVtbnM7XG59O1xuXG5jbGFzcyBSZXNpemVhYmxlQnVmZmVye1xuICBjb25zdHJ1Y3RvcihzaXplPTEwMCl7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgcHJlcGVuZCh2YWwpe1xuICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKXtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoICsgdmFsLmxlbmd0aDtcbiAgICAgIGlmKGxlbmd0aCA+PSB0aGlzLnNpemUpe1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICBpZihsZW5ndGggPj0gdGhpcy5zaXplKXtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSU5WQUxJRF9CVUZGRVJfU1RBVEUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYnVmID0gdGhpcy5idWY7XG4gICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLnNpemUpO1xuICAgICAgdmFsLmNvcHkodGhpcy5idWYsIDApO1xuICAgICAgYnVmLmNvcHkodGhpcy5idWYsIHZhbC5sZW5ndGgpO1xuICAgICAgdGhpcy5sZW5ndGggKz0gdmFsLmxlbmd0aDtcbiAgICB9ZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCsrO1xuICAgICAgaWYobGVuZ3RoID09PSB0aGlzLnNpemUpe1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmID0gdGhpcy5jbG9uZSgpO1xuICAgICAgdGhpcy5idWZbMF0gPSB2YWw7XG4gICAgICBidWYuY29weSh0aGlzLmJ1ZiwxLCAwLCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuICBhcHBlbmQodmFsKXtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCsrO1xuICAgIGlmKGxlbmd0aCA9PT0gdGhpcy5zaXplKXtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfVxuICAgIHRoaXMuYnVmW2xlbmd0aF0gPSB2YWw7XG4gIH1cbiAgY2xvbmUoKXtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpKTtcbiAgfVxuICByZXNpemUoKXtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB0aGlzLnNpemUgPSB0aGlzLnNpemUgKiAyO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLnNpemUpO1xuICAgIHRoaXMuYnVmLmNvcHkoYnVmLDAsIDAsIGxlbmd0aCk7XG4gICAgdGhpcy5idWYgPSBidWY7XG4gIH1cbiAgdG9TdHJpbmcoZW5jb2Rpbmcpe1xuICAgIGlmKGVuY29kaW5nKXtcbiAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCkudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH1lbHNlIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKSk7XG4gICAgfVxuICB9XG4gIHRvSlNPTigpe1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cbiAgcmVzZXQoKXtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuLy8gd2hpdGUgc3BhY2UgY2hhcmFjdGVyc1xuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2hpdGVzcGFjZV9jaGFyYWN0ZXJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucy9DaGFyYWN0ZXJfQ2xhc3NlcyNUeXBlc1xuLy8gXFxmXFxuXFxyXFx0XFx2XFx1MDBhMFxcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZcbmNvbnN0IG5wID0gMTI7XG5jb25zdCBjciQxID0gMTM7IC8vIGBcXHJgLCBjYXJyaWFnZSByZXR1cm4sIDB4MEQgaW4gaGV4YWTDqWNpbWFsLCAxMyBpbiBkZWNpbWFsXG5jb25zdCBubCQxID0gMTA7IC8vIGBcXG5gLCBuZXdsaW5lLCAweDBBIGluIGhleGFkZWNpbWFsLCAxMCBpbiBkZWNpbWFsXG5jb25zdCBzcGFjZSA9IDMyO1xuY29uc3QgdGFiID0gOTtcblxuY29uc3QgaW5pdF9zdGF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICByZXR1cm4ge1xuICAgIGJvbVNraXBwZWQ6IGZhbHNlLFxuICAgIGJ1ZkJ5dGVzU3RhcnQ6IDAsXG4gICAgY2FzdEZpZWxkOiBvcHRpb25zLmNhc3RfZnVuY3Rpb24sXG4gICAgY29tbWVudGluZzogZmFsc2UsXG4gICAgLy8gQ3VycmVudCBlcnJvciBlbmNvdW50ZXJlZCBieSBhIHJlY29yZFxuICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgZW5hYmxlZDogb3B0aW9ucy5mcm9tX2xpbmUgPT09IDEsXG4gICAgZXNjYXBpbmc6IGZhbHNlLFxuICAgIGVzY2FwZUlzUXVvdGU6IEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmVzY2FwZSkgJiYgQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucXVvdGUpICYmIEJ1ZmZlci5jb21wYXJlKG9wdGlvbnMuZXNjYXBlLCBvcHRpb25zLnF1b3RlKSA9PT0gMCxcbiAgICAvLyBjb2x1bW5zIGNhbiBiZSBgZmFsc2VgLCBgdHJ1ZWAsIGBBcnJheWBcbiAgICBleHBlY3RlZFJlY29yZExlbmd0aDogQXJyYXkuaXNBcnJheShvcHRpb25zLmNvbHVtbnMpID8gb3B0aW9ucy5jb2x1bW5zLmxlbmd0aCA6IHVuZGVmaW5lZCxcbiAgICBmaWVsZDogbmV3IFJlc2l6ZWFibGVCdWZmZXIoMjApLFxuICAgIGZpcnN0TGluZVRvSGVhZGVyczogb3B0aW9ucy5jYXN0X2ZpcnN0X2xpbmVfdG9faGVhZGVyLFxuICAgIG5lZWRNb3JlRGF0YVNpemU6IE1hdGgubWF4KFxuICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBzbWFsbGVyIHRoYW4gY29tbWVudFxuICAgICAgb3B0aW9ucy5jb21tZW50ICE9PSBudWxsID8gb3B0aW9ucy5jb21tZW50Lmxlbmd0aCA6IDAsXG4gICAgICAvLyBTa2lwIGlmIHRoZSByZW1haW5pbmcgYnVmZmVyIGNhbiBiZSBkZWxpbWl0ZXJcbiAgICAgIC4uLm9wdGlvbnMuZGVsaW1pdGVyLm1hcCgoZGVsaW1pdGVyKSA9PiBkZWxpbWl0ZXIubGVuZ3RoKSxcbiAgICAgIC8vIFNraXAgaWYgdGhlIHJlbWFpbmluZyBidWZmZXIgY2FuIGJlIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgb3B0aW9ucy5xdW90ZSAhPT0gbnVsbCA/IG9wdGlvbnMucXVvdGUubGVuZ3RoIDogMCxcbiAgICApLFxuICAgIHByZXZpb3VzQnVmOiB1bmRlZmluZWQsXG4gICAgcXVvdGluZzogZmFsc2UsXG4gICAgc3RvcDogZmFsc2UsXG4gICAgcmF3QnVmZmVyOiBuZXcgUmVzaXplYWJsZUJ1ZmZlcigxMDApLFxuICAgIHJlY29yZDogW10sXG4gICAgcmVjb3JkSGFzRXJyb3I6IGZhbHNlLFxuICAgIHJlY29yZF9sZW5ndGg6IDAsXG4gICAgcmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoOiBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoID09PSAwID8gMCA6IE1hdGgubWF4KC4uLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlci5tYXAoKHYpID0+IHYubGVuZ3RoKSksXG4gICAgdHJpbUNoYXJzOiBbQnVmZmVyLmZyb20oJyAnLCBvcHRpb25zLmVuY29kaW5nKVswXSwgQnVmZmVyLmZyb20oJ1xcdCcsIG9wdGlvbnMuZW5jb2RpbmcpWzBdXSxcbiAgICB3YXNRdW90aW5nOiBmYWxzZSxcbiAgICB3YXNSb3dEZWxpbWl0ZXI6IGZhbHNlLFxuICAgIHRpbWNoYXJzOiBbXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbY3IkMV0sICd1dGY4JykudG9TdHJpbmcoKSwgb3B0aW9ucy5lbmNvZGluZyksXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbbmwkMV0sICd1dGY4JykudG9TdHJpbmcoKSwgb3B0aW9ucy5lbmNvZGluZyksXG4gICAgICBCdWZmZXIuZnJvbShCdWZmZXIuZnJvbShbbnBdLCAndXRmOCcpLnRvU3RyaW5nKCksIG9wdGlvbnMuZW5jb2RpbmcpLFxuICAgICAgQnVmZmVyLmZyb20oQnVmZmVyLmZyb20oW3NwYWNlXSwgJ3V0ZjgnKS50b1N0cmluZygpLCBvcHRpb25zLmVuY29kaW5nKSxcbiAgICAgIEJ1ZmZlci5mcm9tKEJ1ZmZlci5mcm9tKFt0YWJdLCAndXRmOCcpLnRvU3RyaW5nKCksIG9wdGlvbnMuZW5jb2RpbmcpLFxuICAgIF1cbiAgfTtcbn07XG5cbmNvbnN0IHVuZGVyc2NvcmUkMSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihfLCBtYXRjaCl7XG4gICAgcmV0dXJuICdfJyArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufTtcblxuY29uc3Qgbm9ybWFsaXplX29wdGlvbnMkMSA9IGZ1bmN0aW9uKG9wdHMpe1xuICBjb25zdCBvcHRpb25zID0ge307XG4gIC8vIE1lcmdlIHdpdGggdXNlciBvcHRpb25zXG4gIGZvcihjb25zdCBvcHQgaW4gb3B0cyl7XG4gICAgb3B0aW9uc1t1bmRlcnNjb3JlJDEob3B0KV0gPSBvcHRzW29wdF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZW5jb2RpbmdgXG4gIC8vIE5vdGU6IGRlZmluZWQgZmlyc3QgYmVjYXVzZSBvdGhlciBvcHRpb25zIGRlcGVuZHMgb24gaXRcbiAgLy8gdG8gY29udmVydCBjaGFycy9zdHJpbmdzIGludG8gYnVmZmVycy5cbiAgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZW5jb2RpbmcgPT09IHRydWUpe1xuICAgIG9wdGlvbnMuZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1lbHNlIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09IG51bGwgfHwgb3B0aW9ucy5lbmNvZGluZyA9PT0gZmFsc2Upe1xuICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBudWxsO1xuICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5lbmNvZGluZyAhPT0gJ3N0cmluZycgJiYgb3B0aW9ucy5lbmNvZGluZyAhPT0gbnVsbCl7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yJDEoJ0NTVl9JTlZBTElEX09QVElPTl9FTkNPRElORycsIFtcbiAgICAgICdJbnZhbGlkIG9wdGlvbiBlbmNvZGluZzonLFxuICAgICAgJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbCB0byByZXR1cm4gYSBidWZmZXIsJyxcbiAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVuY29kaW5nKX1gXG4gICAgXSwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgYm9tYFxuICBpZihvcHRpb25zLmJvbSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuYm9tID09PSBudWxsIHx8IG9wdGlvbnMuYm9tID09PSBmYWxzZSl7XG4gICAgb3B0aW9ucy5ib20gPSBmYWxzZTtcbiAgfWVsc2UgaWYob3B0aW9ucy5ib20gIT09IHRydWUpe1xuICAgIHRocm93IG5ldyBDc3ZFcnJvciQxKCdDU1ZfSU5WQUxJRF9PUFRJT05fQk9NJywgW1xuICAgICAgJ0ludmFsaWQgb3B0aW9uIGJvbTonLCAnYm9tIG11c3QgYmUgdHJ1ZSwnLFxuICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9tKX1gXG4gICAgXSwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY2FzdGBcbiAgb3B0aW9ucy5jYXN0X2Z1bmN0aW9uID0gbnVsbDtcbiAgaWYob3B0aW9ucy5jYXN0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0ID09PSBudWxsIHx8IG9wdGlvbnMuY2FzdCA9PT0gZmFsc2UgfHwgb3B0aW9ucy5jYXN0ID09PSAnJyl7XG4gICAgb3B0aW9ucy5jYXN0ID0gdW5kZWZpbmVkO1xuICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5jYXN0ID09PSAnZnVuY3Rpb24nKXtcbiAgICBvcHRpb25zLmNhc3RfZnVuY3Rpb24gPSBvcHRpb25zLmNhc3Q7XG4gICAgb3B0aW9ucy5jYXN0ID0gdHJ1ZTtcbiAgfWVsc2UgaWYob3B0aW9ucy5jYXN0ICE9PSB0cnVlKXtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfT1BUSU9OX0NBU1QnLCBbXG4gICAgICAnSW52YWxpZCBvcHRpb24gY2FzdDonLCAnY2FzdCBtdXN0IGJlIHRydWUgb3IgYSBmdW5jdGlvbiwnLFxuICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuY2FzdCl9YFxuICAgIF0sIG9wdGlvbnMpO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNhc3RfZGF0ZWBcbiAgaWYob3B0aW9ucy5jYXN0X2RhdGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3RfZGF0ZSA9PT0gbnVsbCB8fCBvcHRpb25zLmNhc3RfZGF0ZSA9PT0gZmFsc2UgfHwgb3B0aW9ucy5jYXN0X2RhdGUgPT09ICcnKXtcbiAgICBvcHRpb25zLmNhc3RfZGF0ZSA9IGZhbHNlO1xuICB9ZWxzZSBpZihvcHRpb25zLmNhc3RfZGF0ZSA9PT0gdHJ1ZSl7XG4gICAgb3B0aW9ucy5jYXN0X2RhdGUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBjb25zdCBkYXRlID0gRGF0ZS5wYXJzZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gIWlzTmFOKGRhdGUpID8gbmV3IERhdGUoZGF0ZSkgOiB2YWx1ZTtcbiAgICB9O1xuICB9ZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuY2FzdF9kYXRlICE9PSAnZnVuY3Rpb24nKXtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfT1BUSU9OX0NBU1RfREFURScsIFtcbiAgICAgICdJbnZhbGlkIG9wdGlvbiBjYXN0X2RhdGU6JywgJ2Nhc3RfZGF0ZSBtdXN0IGJlIHRydWUgb3IgYSBmdW5jdGlvbiwnLFxuICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuY2FzdF9kYXRlKX1gXG4gICAgXSwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY29sdW1uc2BcbiAgb3B0aW9ucy5jYXN0X2ZpcnN0X2xpbmVfdG9faGVhZGVyID0gbnVsbDtcbiAgaWYob3B0aW9ucy5jb2x1bW5zID09PSB0cnVlKXtcbiAgICAvLyBGaWVsZHMgaW4gdGhlIGZpcnN0IGxpbmUgYXJlIGNvbnZlcnRlZCBhcy1pcyB0byBjb2x1bW5zXG4gICAgb3B0aW9ucy5jYXN0X2ZpcnN0X2xpbmVfdG9faGVhZGVyID0gdW5kZWZpbmVkO1xuICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5jb2x1bW5zID09PSAnZnVuY3Rpb24nKXtcbiAgICBvcHRpb25zLmNhc3RfZmlyc3RfbGluZV90b19oZWFkZXIgPSBvcHRpb25zLmNvbHVtbnM7XG4gICAgb3B0aW9ucy5jb2x1bW5zID0gdHJ1ZTtcbiAgfWVsc2UgaWYoQXJyYXkuaXNBcnJheShvcHRpb25zLmNvbHVtbnMpKXtcbiAgICBvcHRpb25zLmNvbHVtbnMgPSBub3JtYWxpemVfY29sdW1uc19hcnJheShvcHRpb25zLmNvbHVtbnMpO1xuICB9ZWxzZSBpZihvcHRpb25zLmNvbHVtbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNvbHVtbnMgPT09IG51bGwgfHwgb3B0aW9ucy5jb2x1bW5zID09PSBmYWxzZSl7XG4gICAgb3B0aW9ucy5jb2x1bW5zID0gZmFsc2U7XG4gIH1lbHNlIHtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfT1BUSU9OX0NPTFVNTlMnLCBbXG4gICAgICAnSW52YWxpZCBvcHRpb24gY29sdW1uczonLFxuICAgICAgJ2V4cGVjdCBhbiBhcnJheSwgYSBmdW5jdGlvbiBvciB0cnVlLCcsXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb2x1bW5zKX1gXG4gICAgXSwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZ3JvdXBfY29sdW1uc19ieV9uYW1lYFxuICBpZihvcHRpb25zLmdyb3VwX2NvbHVtbnNfYnlfbmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZ3JvdXBfY29sdW1uc19ieV9uYW1lID09PSBudWxsIHx8IG9wdGlvbnMuZ3JvdXBfY29sdW1uc19ieV9uYW1lID09PSBmYWxzZSl7XG4gICAgb3B0aW9ucy5ncm91cF9jb2x1bW5zX2J5X25hbWUgPSBmYWxzZTtcbiAgfWVsc2UgaWYob3B0aW9ucy5ncm91cF9jb2x1bW5zX2J5X25hbWUgIT09IHRydWUpe1xuICAgIHRocm93IG5ldyBDc3ZFcnJvciQxKCdDU1ZfSU5WQUxJRF9PUFRJT05fR1JPVVBfQ09MVU1OU19CWV9OQU1FJywgW1xuICAgICAgJ0ludmFsaWQgb3B0aW9uIGdyb3VwX2NvbHVtbnNfYnlfbmFtZTonLFxuICAgICAgJ2V4cGVjdCBhbiBib29sZWFuLCcsXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ncm91cF9jb2x1bW5zX2J5X25hbWUpfWBcbiAgICBdLCBvcHRpb25zKTtcbiAgfWVsc2UgaWYob3B0aW9ucy5jb2x1bW5zID09PSBmYWxzZSl7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yJDEoJ0NTVl9JTlZBTElEX09QVElPTl9HUk9VUF9DT0xVTU5TX0JZX05BTUUnLCBbXG4gICAgICAnSW52YWxpZCBvcHRpb24gZ3JvdXBfY29sdW1uc19ieV9uYW1lOicsXG4gICAgICAndGhlIGBjb2x1bW5zYCBtb2RlIG11c3QgYmUgYWN0aXZhdGVkLidcbiAgICBdLCBvcHRpb25zKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjb21tZW50YFxuICBpZihvcHRpb25zLmNvbW1lbnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNvbW1lbnQgPT09IG51bGwgfHwgb3B0aW9ucy5jb21tZW50ID09PSBmYWxzZSB8fCBvcHRpb25zLmNvbW1lbnQgPT09ICcnKXtcbiAgICBvcHRpb25zLmNvbW1lbnQgPSBudWxsO1xuICB9ZWxzZSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ3N0cmluZycpe1xuICAgICAgb3B0aW9ucy5jb21tZW50ID0gQnVmZmVyLmZyb20ob3B0aW9ucy5jb21tZW50LCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICB9XG4gICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmNvbW1lbnQpKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvciQxKCdDU1ZfSU5WQUxJRF9PUFRJT05fQ09NTUVOVCcsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGNvbW1lbnQ6JyxcbiAgICAgICAgJ2NvbW1lbnQgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZywnLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb21tZW50KX1gXG4gICAgICBdLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZGVsaW1pdGVyYFxuICBjb25zdCBkZWxpbWl0ZXJfanNvbiA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgaWYoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5kZWxpbWl0ZXIpKSBvcHRpb25zLmRlbGltaXRlciA9IFtvcHRpb25zLmRlbGltaXRlcl07XG4gIGlmKG9wdGlvbnMuZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCl7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yJDEoJ0NTVl9JTlZBTElEX09QVElPTl9ERUxJTUlURVInLCBbXG4gICAgICAnSW52YWxpZCBvcHRpb24gZGVsaW1pdGVyOicsXG4gICAgICAnZGVsaW1pdGVyIG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nIG9yIGJ1ZmZlciBvciBhcnJheSBvZiBzdHJpbmd8YnVmZmVyLCcsXG4gICAgICBgZ290ICR7ZGVsaW1pdGVyX2pzb259YFxuICAgIF0sIG9wdGlvbnMpO1xuICB9XG4gIG9wdGlvbnMuZGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXIubWFwKGZ1bmN0aW9uKGRlbGltaXRlcil7XG4gICAgaWYoZGVsaW1pdGVyID09PSB1bmRlZmluZWQgfHwgZGVsaW1pdGVyID09PSBudWxsIHx8IGRlbGltaXRlciA9PT0gZmFsc2Upe1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCcsJywgb3B0aW9ucy5lbmNvZGluZyk7XG4gICAgfVxuICAgIGlmKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICdzdHJpbmcnKXtcbiAgICAgIGRlbGltaXRlciA9IEJ1ZmZlci5mcm9tKGRlbGltaXRlciwgb3B0aW9ucy5lbmNvZGluZyk7XG4gICAgfVxuICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIoZGVsaW1pdGVyKSB8fCBkZWxpbWl0ZXIubGVuZ3RoID09PSAwKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvciQxKCdDU1ZfSU5WQUxJRF9PUFRJT05fREVMSU1JVEVSJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gZGVsaW1pdGVyOicsXG4gICAgICAgICdkZWxpbWl0ZXIgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgb3IgYnVmZmVyIG9yIGFycmF5IG9mIHN0cmluZ3xidWZmZXIsJyxcbiAgICAgICAgYGdvdCAke2RlbGltaXRlcl9qc29ufWBcbiAgICAgIF0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsaW1pdGVyO1xuICB9KTtcbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZXNjYXBlYFxuICBpZihvcHRpb25zLmVzY2FwZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZXNjYXBlID09PSB0cnVlKXtcbiAgICBvcHRpb25zLmVzY2FwZSA9IEJ1ZmZlci5mcm9tKCdcIicsIG9wdGlvbnMuZW5jb2RpbmcpO1xuICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5lc2NhcGUgPT09ICdzdHJpbmcnKXtcbiAgICBvcHRpb25zLmVzY2FwZSA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMuZXNjYXBlLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgfWVsc2UgaWYgKG9wdGlvbnMuZXNjYXBlID09PSBudWxsIHx8IG9wdGlvbnMuZXNjYXBlID09PSBmYWxzZSl7XG4gICAgb3B0aW9ucy5lc2NhcGUgPSBudWxsO1xuICB9XG4gIGlmKG9wdGlvbnMuZXNjYXBlICE9PSBudWxsKXtcbiAgICBpZighQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuZXNjYXBlKSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBlc2NhcGUgbXVzdCBiZSBhIGJ1ZmZlciwgYSBzdHJpbmcgb3IgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVzY2FwZSl9YCk7XG4gICAgfVxuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGZyb21gXG4gIGlmKG9wdGlvbnMuZnJvbSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZnJvbSA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5mcm9tID0gMTtcbiAgfWVsc2Uge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLmZyb20gPT09ICdzdHJpbmcnICYmIC9cXGQrLy50ZXN0KG9wdGlvbnMuZnJvbSkpe1xuICAgICAgb3B0aW9ucy5mcm9tID0gcGFyc2VJbnQob3B0aW9ucy5mcm9tKTtcbiAgICB9XG4gICAgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmZyb20pKXtcbiAgICAgIGlmKG9wdGlvbnMuZnJvbSA8IDApe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBmcm9tIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLmZyb20pfWApO1xuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IGZyb20gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmZyb20pfWApO1xuICAgIH1cbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBmcm9tX2xpbmVgXG4gIGlmKG9wdGlvbnMuZnJvbV9saW5lID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5mcm9tX2xpbmUgPT09IG51bGwpe1xuICAgIG9wdGlvbnMuZnJvbV9saW5lID0gMTtcbiAgfWVsc2Uge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLmZyb21fbGluZSA9PT0gJ3N0cmluZycgJiYgL1xcZCsvLnRlc3Qob3B0aW9ucy5mcm9tX2xpbmUpKXtcbiAgICAgIG9wdGlvbnMuZnJvbV9saW5lID0gcGFyc2VJbnQob3B0aW9ucy5mcm9tX2xpbmUpO1xuICAgIH1cbiAgICBpZihOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMuZnJvbV9saW5lKSl7XG4gICAgICBpZihvcHRpb25zLmZyb21fbGluZSA8PSAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogZnJvbV9saW5lIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLmZyb21fbGluZSl9YCk7XG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogZnJvbV9saW5lIG11c3QgYmUgYW4gaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy5mcm9tX2xpbmUpfWApO1xuICAgIH1cbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9ucyBgaWdub3JlX2xhc3RfZGVsaW1pdGVyc2BcbiAgaWYob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSBudWxsKXtcbiAgICBvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPSBmYWxzZTtcbiAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gJ251bWJlcicpe1xuICAgIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9IE1hdGguZmxvb3Iob3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzKTtcbiAgICBpZihvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09IDApe1xuICAgICAgb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID0gZmFsc2U7XG4gICAgfVxuICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzICE9PSAnYm9vbGVhbicpe1xuICAgIHRocm93IG5ldyBDc3ZFcnJvciQxKCdDU1ZfSU5WQUxJRF9PUFRJT05fSUdOT1JFX0xBU1RfREVMSU1JVEVSUycsIFtcbiAgICAgICdJbnZhbGlkIG9wdGlvbiBgaWdub3JlX2xhc3RfZGVsaW1pdGVyc2A6JyxcbiAgICAgICd0aGUgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWUgb3IgYW4gaW50ZWdlciwnLFxuICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyl9YFxuICAgIF0sIG9wdGlvbnMpO1xuICB9XG4gIGlmKG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gdHJ1ZSAmJiBvcHRpb25zLmNvbHVtbnMgPT09IGZhbHNlKXtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lHTk9SRV9MQVNUX0RFTElNSVRFUlNfUkVRVUlSRVNfQ09MVU1OUycsIFtcbiAgICAgICdUaGUgb3B0aW9uIGBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzYCcsXG4gICAgICAncmVxdWlyZXMgdGhlIGFjdGl2YXRpb24gb2YgdGhlIGBjb2x1bW5zYCBvcHRpb24nXG4gICAgXSwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgaW5mb2BcbiAgaWYob3B0aW9ucy5pbmZvID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pbmZvID09PSBudWxsIHx8IG9wdGlvbnMuaW5mbyA9PT0gZmFsc2Upe1xuICAgIG9wdGlvbnMuaW5mbyA9IGZhbHNlO1xuICB9ZWxzZSBpZihvcHRpb25zLmluZm8gIT09IHRydWUpe1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IGluZm8gbXVzdCBiZSB0cnVlLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmluZm8pfWApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYG1heF9yZWNvcmRfc2l6ZWBcbiAgaWYob3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA9PT0gbnVsbCB8fCBvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA9PT0gZmFsc2Upe1xuICAgIG9wdGlvbnMubWF4X3JlY29yZF9zaXplID0gMDtcbiAgfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSkgJiYgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPj0gMCk7ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPT09ICdzdHJpbmcnICYmIC9cXGQrLy50ZXN0KG9wdGlvbnMubWF4X3JlY29yZF9zaXplKSl7XG4gICAgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPSBwYXJzZUludChvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSk7XG4gIH1lbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBtYXhfcmVjb3JkX3NpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMubWF4X3JlY29yZF9zaXplKX1gKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBvYmpuYW1lYFxuICBpZihvcHRpb25zLm9iam5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm9iam5hbWUgPT09IG51bGwgfHwgb3B0aW9ucy5vYmpuYW1lID09PSBmYWxzZSl7XG4gICAgb3B0aW9ucy5vYmpuYW1lID0gdW5kZWZpbmVkO1xuICB9ZWxzZSBpZihCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5vYmpuYW1lKSl7XG4gICAgaWYob3B0aW9ucy5vYmpuYW1lLmxlbmd0aCA9PT0gMCl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBvYmpuYW1lIG11c3QgYmUgYSBub24gZW1wdHkgYnVmZmVyYCk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09IG51bGwpO2Vsc2Uge1xuICAgICAgb3B0aW9ucy5vYmpuYW1lID0gb3B0aW9ucy5vYmpuYW1lLnRvU3RyaW5nKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIH1cbiAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMub2JqbmFtZSA9PT0gJ3N0cmluZycpe1xuICAgIGlmKG9wdGlvbnMub2JqbmFtZS5sZW5ndGggPT09IDApe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogb2JqbmFtZSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZ2ApO1xuICAgIH1cbiAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5vYmpuYW1lID09PSAnbnVtYmVyJyk7ZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogb2JqbmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyLCBnb3QgJHtvcHRpb25zLm9iam5hbWV9YCk7XG4gIH1cbiAgaWYob3B0aW9ucy5vYmpuYW1lICE9PSB1bmRlZmluZWQpe1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLm9iam5hbWUgPT09ICdudW1iZXInKXtcbiAgICAgIGlmKG9wdGlvbnMuY29sdW1ucyAhPT0gZmFsc2Upe1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBPcHRpb246IG9iam5hbWUgaW5kZXggY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggY29sdW1ucyBvciBiZSBkZWZpbmVkIGFzIGEgZmllbGQnKTtcbiAgICAgIH1cbiAgICB9ZWxzZSB7IC8vIEEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gICAgICBpZihvcHRpb25zLmNvbHVtbnMgPT09IGZhbHNlKXtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgT3B0aW9uOiBvYmpuYW1lIGZpZWxkIG11c3QgYmUgY29tYmluZWQgd2l0aCBjb2x1bW5zIG9yIGJlIGRlZmluZWQgYXMgYW4gaW5kZXgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgb25fcmVjb3JkYFxuICBpZihvcHRpb25zLm9uX3JlY29yZCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMub25fcmVjb3JkID09PSBudWxsKXtcbiAgICBvcHRpb25zLm9uX3JlY29yZCA9IHVuZGVmaW5lZDtcbiAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMub25fcmVjb3JkICE9PSAnZnVuY3Rpb24nKXtcbiAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfT1BUSU9OX09OX1JFQ09SRCcsIFtcbiAgICAgICdJbnZhbGlkIG9wdGlvbiBgb25fcmVjb3JkYDonLFxuICAgICAgJ2V4cGVjdCBhIGZ1bmN0aW9uLCcsXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5vbl9yZWNvcmQpfWBcbiAgICBdLCBvcHRpb25zKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWBcbiAgaWYob3B0aW9ucy5xdW90ZSA9PT0gbnVsbCB8fCBvcHRpb25zLnF1b3RlID09PSBmYWxzZSB8fCBvcHRpb25zLnF1b3RlID09PSAnJyl7XG4gICAgb3B0aW9ucy5xdW90ZSA9IG51bGw7XG4gIH1lbHNlIHtcbiAgICBpZihvcHRpb25zLnF1b3RlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZSA9PT0gdHJ1ZSl7XG4gICAgICBvcHRpb25zLnF1b3RlID0gQnVmZmVyLmZyb20oJ1wiJywgb3B0aW9ucy5lbmNvZGluZyk7XG4gICAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMucXVvdGUgPT09ICdzdHJpbmcnKXtcbiAgICAgIG9wdGlvbnMucXVvdGUgPSBCdWZmZXIuZnJvbShvcHRpb25zLnF1b3RlLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICB9XG4gICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnF1b3RlKSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBxdW90ZSBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnF1b3RlKX1gKTtcbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmF3YFxuICBpZihvcHRpb25zLnJhdyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmF3ID09PSBudWxsIHx8IG9wdGlvbnMucmF3ID09PSBmYWxzZSl7XG4gICAgb3B0aW9ucy5yYXcgPSBmYWxzZTtcbiAgfWVsc2UgaWYob3B0aW9ucy5yYXcgIT09IHRydWUpe1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJhdyBtdXN0IGJlIHRydWUsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucmF3KX1gKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGByZWNvcmRfZGVsaW1pdGVyYFxuICBpZihvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCl7XG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gW107XG4gIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpKXtcbiAgICBpZihvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoID09PSAwKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvciQxKCdDU1ZfSU5WQUxJRF9PUFRJT05fUkVDT1JEX0RFTElNSVRFUicsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGByZWNvcmRfZGVsaW1pdGVyYDonLFxuICAgICAgICAndmFsdWUgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgb3IgYnVmZmVyLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpfWBcbiAgICAgIF0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBbb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyXTtcbiAgfWVsc2UgaWYoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKSl7XG4gICAgdGhyb3cgbmV3IENzdkVycm9yJDEoJ0NTVl9JTlZBTElEX09QVElPTl9SRUNPUkRfREVMSU1JVEVSJywgW1xuICAgICAgJ0ludmFsaWQgb3B0aW9uIGByZWNvcmRfZGVsaW1pdGVyYDonLFxuICAgICAgJ3ZhbHVlIG11c3QgYmUgYSBzdHJpbmcsIGEgYnVmZmVyIG9yIGFycmF5IG9mIHN0cmluZ3xidWZmZXIsJyxcbiAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpfWBcbiAgICBdLCBvcHRpb25zKTtcbiAgfVxuICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIubWFwKGZ1bmN0aW9uKHJkLCBpKXtcbiAgICBpZih0eXBlb2YgcmQgIT09ICdzdHJpbmcnICYmICEgQnVmZmVyLmlzQnVmZmVyKHJkKSl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfT1BUSU9OX1JFQ09SRF9ERUxJTUlURVInLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBgcmVjb3JkX2RlbGltaXRlcmA6JyxcbiAgICAgICAgJ3ZhbHVlIG11c3QgYmUgYSBzdHJpbmcsIGEgYnVmZmVyIG9yIGFycmF5IG9mIHN0cmluZ3xidWZmZXInLFxuICAgICAgICBgYXQgaW5kZXggJHtpfSxgLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkocmQpfWBcbiAgICAgIF0sIG9wdGlvbnMpO1xuICAgIH1lbHNlIGlmKHJkLmxlbmd0aCA9PT0gMCl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfT1BUSU9OX1JFQ09SRF9ERUxJTUlURVInLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBgcmVjb3JkX2RlbGltaXRlcmA6JyxcbiAgICAgICAgJ3ZhbHVlIG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nIG9yIGJ1ZmZlcicsXG4gICAgICAgIGBhdCBpbmRleCAke2l9LGAsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShyZCl9YFxuICAgICAgXSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmKHR5cGVvZiByZCA9PT0gJ3N0cmluZycpe1xuICAgICAgcmQgPSBCdWZmZXIuZnJvbShyZCwgb3B0aW9ucy5lbmNvZGluZyk7XG4gICAgfVxuICAgIHJldHVybiByZDtcbiAgfSk7XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJlbGF4X2NvbHVtbl9jb3VudGBcbiAgaWYodHlwZW9mIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID09PSAnYm9vbGVhbicpO2Vsc2UgaWYob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudCA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQgPSBmYWxzZTtcbiAgfWVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJlbGF4X2NvbHVtbl9jb3VudCBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQpfWApO1xuICB9XG4gIGlmKHR5cGVvZiBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID09PSAnYm9vbGVhbicpO2Vsc2UgaWYob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbGVzcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X2xlc3MgPT09IG51bGwpe1xuICAgIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X2xlc3MgPSBmYWxzZTtcbiAgfWVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJlbGF4X2NvbHVtbl9jb3VudF9sZXNzIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzKX1gKTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSA9PT0gJ2Jvb2xlYW4nKTtlbHNlIGlmKG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X21vcmUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9tb3JlID09PSBudWxsKXtcbiAgICBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9tb3JlID0gZmFsc2U7XG4gIH1lbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiByZWxheF9jb2x1bW5fY291bnRfbW9yZSBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSl9YCk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmVsYXhfcXVvdGVzYFxuICBpZih0eXBlb2Ygb3B0aW9ucy5yZWxheF9xdW90ZXMgPT09ICdib29sZWFuJyk7ZWxzZSBpZihvcHRpb25zLnJlbGF4X3F1b3RlcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmVsYXhfcXVvdGVzID09PSBudWxsKXtcbiAgICBvcHRpb25zLnJlbGF4X3F1b3RlcyA9IGZhbHNlO1xuICB9ZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogcmVsYXhfcXVvdGVzIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlbGF4X3F1b3Rlcyl9YCk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgc2tpcF9lbXB0eV9saW5lc2BcbiAgaWYodHlwZW9mIG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9PT0gJ2Jvb2xlYW4nKTtlbHNlIGlmKG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5za2lwX2VtcHR5X2xpbmVzID0gZmFsc2U7XG4gIH1lbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBza2lwX2VtcHR5X2xpbmVzIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnNraXBfZW1wdHlfbGluZXMpfWApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHNraXBfcmVjb3Jkc193aXRoX2VtcHR5X3ZhbHVlc2BcbiAgaWYodHlwZW9mIG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzID09PSAnYm9vbGVhbicpO2Vsc2UgaWYob3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNraXBfcmVjb3Jkc193aXRoX2VtcHR5X3ZhbHVlcyA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMgPSBmYWxzZTtcbiAgfWVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHNraXBfcmVjb3Jkc193aXRoX2VtcHR5X3ZhbHVlcyBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMpfWApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHNraXBfcmVjb3Jkc193aXRoX2Vycm9yYFxuICBpZih0eXBlb2Ygb3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lcnJvciA9PT0gJ2Jvb2xlYW4nKTtlbHNlIGlmKG9wdGlvbnMuc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3IgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNraXBfcmVjb3Jkc193aXRoX2Vycm9yID09PSBudWxsKXtcbiAgICBvcHRpb25zLnNraXBfcmVjb3Jkc193aXRoX2Vycm9yID0gZmFsc2U7XG4gIH1lbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBza2lwX3JlY29yZHNfd2l0aF9lcnJvciBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5za2lwX3JlY29yZHNfd2l0aF9lcnJvcil9YCk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcnRyaW1gXG4gIGlmKG9wdGlvbnMucnRyaW0gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnJ0cmltID09PSBudWxsIHx8IG9wdGlvbnMucnRyaW0gPT09IGZhbHNlKXtcbiAgICBvcHRpb25zLnJ0cmltID0gZmFsc2U7XG4gIH1lbHNlIGlmKG9wdGlvbnMucnRyaW0gIT09IHRydWUpe1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJ0cmltIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJ0cmltKX1gKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBsdHJpbWBcbiAgaWYob3B0aW9ucy5sdHJpbSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubHRyaW0gPT09IG51bGwgfHwgb3B0aW9ucy5sdHJpbSA9PT0gZmFsc2Upe1xuICAgIG9wdGlvbnMubHRyaW0gPSBmYWxzZTtcbiAgfWVsc2UgaWYob3B0aW9ucy5sdHJpbSAhPT0gdHJ1ZSl7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogbHRyaW0gbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMubHRyaW0pfWApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHRyaW1gXG4gIGlmKG9wdGlvbnMudHJpbSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudHJpbSA9PT0gbnVsbCB8fCBvcHRpb25zLnRyaW0gPT09IGZhbHNlKXtcbiAgICBvcHRpb25zLnRyaW0gPSBmYWxzZTtcbiAgfWVsc2UgaWYob3B0aW9ucy50cmltICE9PSB0cnVlKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiB0cmltIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnRyaW0pfWApO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb25zIGB0cmltYCwgYGx0cmltYCBhbmQgYHJ0cmltYFxuICBpZihvcHRpb25zLnRyaW0gPT09IHRydWUgJiYgb3B0cy5sdHJpbSAhPT0gZmFsc2Upe1xuICAgIG9wdGlvbnMubHRyaW0gPSB0cnVlO1xuICB9ZWxzZSBpZihvcHRpb25zLmx0cmltICE9PSB0cnVlKXtcbiAgICBvcHRpb25zLmx0cmltID0gZmFsc2U7XG4gIH1cbiAgaWYob3B0aW9ucy50cmltID09PSB0cnVlICYmIG9wdHMucnRyaW0gIT09IGZhbHNlKXtcbiAgICBvcHRpb25zLnJ0cmltID0gdHJ1ZTtcbiAgfWVsc2UgaWYob3B0aW9ucy5ydHJpbSAhPT0gdHJ1ZSl7XG4gICAgb3B0aW9ucy5ydHJpbSA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHRvYFxuICBpZihvcHRpb25zLnRvID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy50byA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy50byA9IC0xO1xuICB9ZWxzZSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMudG8gPT09ICdzdHJpbmcnICYmIC9cXGQrLy50ZXN0KG9wdGlvbnMudG8pKXtcbiAgICAgIG9wdGlvbnMudG8gPSBwYXJzZUludChvcHRpb25zLnRvKTtcbiAgICB9XG4gICAgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLnRvKSl7XG4gICAgICBpZihvcHRpb25zLnRvIDw9IDApe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiB0byBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBncmVhdGVyIHRoYW4gMCwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy50byl9YCk7XG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogdG8gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvKX1gKTtcbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgdG9fbGluZWBcbiAgaWYob3B0aW9ucy50b19saW5lID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy50b19saW5lID09PSBudWxsKXtcbiAgICBvcHRpb25zLnRvX2xpbmUgPSAtMTtcbiAgfWVsc2Uge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLnRvX2xpbmUgPT09ICdzdHJpbmcnICYmIC9cXGQrLy50ZXN0KG9wdGlvbnMudG9fbGluZSkpe1xuICAgICAgb3B0aW9ucy50b19saW5lID0gcGFyc2VJbnQob3B0aW9ucy50b19saW5lKTtcbiAgICB9XG4gICAgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLnRvX2xpbmUpKXtcbiAgICAgIGlmKG9wdGlvbnMudG9fbGluZSA8PSAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogdG9fbGluZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBncmVhdGVyIHRoYW4gMCwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy50b19saW5lKX1gKTtcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiB0b19saW5lIG11c3QgYmUgYW4gaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy50b19saW5lKX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5jb25zdCBpc1JlY29yZEVtcHR5ID0gZnVuY3Rpb24ocmVjb3JkKXtcbiAgcmV0dXJuIHJlY29yZC5ldmVyeSgoZmllbGQpID0+IGZpZWxkID09IG51bGwgfHwgZmllbGQudG9TdHJpbmcgJiYgZmllbGQudG9TdHJpbmcoKS50cmltKCkgPT09ICcnKTtcbn07XG5cbmNvbnN0IGNyID0gMTM7IC8vIGBcXHJgLCBjYXJyaWFnZSByZXR1cm4sIDB4MEQgaW4gaGV4YWTDqWNpbWFsLCAxMyBpbiBkZWNpbWFsXG5jb25zdCBubCA9IDEwOyAvLyBgXFxuYCwgbmV3bGluZSwgMHgwQSBpbiBoZXhhZGVjaW1hbCwgMTAgaW4gZGVjaW1hbFxuXG5jb25zdCBib21zID0ge1xuICAvLyBOb3RlLCB0aGUgZm9sbG93aW5nIGFyZSBlcXVhbHM6XG4gIC8vIEJ1ZmZlci5mcm9tKFwiXFx1ZmVmZlwiKVxuICAvLyBCdWZmZXIuZnJvbShbMjM5LCAxODcsIDE5MV0pXG4gIC8vIEJ1ZmZlci5mcm9tKCdFRkJCQkYnLCAnaGV4JylcbiAgJ3V0ZjgnOiBCdWZmZXIuZnJvbShbMjM5LCAxODcsIDE5MV0pLFxuICAvLyBOb3RlLCB0aGUgZm9sbG93aW5nIGFyZSBlcXVhbHM6XG4gIC8vIEJ1ZmZlci5mcm9tIFwiXFx1ZmVmZlwiLCAndXRmMTZsZVxuICAvLyBCdWZmZXIuZnJvbShbMjU1LCAyNTRdKVxuICAndXRmMTZsZSc6IEJ1ZmZlci5mcm9tKFsyNTUsIDI1NF0pXG59O1xuXG5jb25zdCB0cmFuc2Zvcm0kMSA9IGZ1bmN0aW9uKG9yaWdpbmFsX29wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpbmZvID0ge1xuICAgIGJ5dGVzOiAwLFxuICAgIGNvbW1lbnRfbGluZXM6IDAsXG4gICAgZW1wdHlfbGluZXM6IDAsXG4gICAgaW52YWxpZF9maWVsZF9sZW5ndGg6IDAsXG4gICAgbGluZXM6IDEsXG4gICAgcmVjb3JkczogMFxuICB9O1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplX29wdGlvbnMkMShvcmlnaW5hbF9vcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBpbmZvOiBpbmZvLFxuICAgIG9yaWdpbmFsX29wdGlvbnM6IG9yaWdpbmFsX29wdGlvbnMsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBzdGF0ZTogaW5pdF9zdGF0ZShvcHRpb25zKSxcbiAgICBfX25lZWRNb3JlRGF0YTogZnVuY3Rpb24oaSwgYnVmTGVuLCBlbmQpe1xuICAgICAgaWYoZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCB7ZW5jb2RpbmcsIGVzY2FwZSwgcXVvdGV9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3Qge3F1b3RpbmcsIG5lZWRNb3JlRGF0YVNpemUsIHJlY29yZERlbGltaXRlck1heExlbmd0aH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbnVtT2ZDaGFyTGVmdCA9IGJ1ZkxlbiAtIGkgLSAxO1xuICAgICAgY29uc3QgcmVxdWlyZWRMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgbmVlZE1vcmVEYXRhU2l6ZSxcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBzbWFsbGVyIHRoYW4gcmVjb3JkIGRlbGltaXRlclxuICAgICAgICAvLyBJZiBcInJlY29yZF9kZWxpbWl0ZXJcIiBpcyB5ZXQgdG8gYmUgZGlzY292ZXJlZDpcbiAgICAgICAgLy8gMS4gSXQgaXMgZXF1YWxzIHRvIGBbXWAgYW5kIFwicmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoXCIgZXF1YWxzIGAwYFxuICAgICAgICAvLyAyLiBXZSBzZXQgdGhlIGxlbmd0aCB0byB3aW5kb3dzIGxpbmUgZW5kaW5nIGluIHRoZSBjdXJyZW50IGVuY29kaW5nXG4gICAgICAgIC8vIE5vdGUsIHRoYXQgZW5jb2RpbmcgaXMga25vd24gZnJvbSB1c2VyIG9yIGJvbSBkaXNjb3ZlcnkgYXQgdGhhdCBwb2ludFxuICAgICAgICAvLyByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGgsXG4gICAgICAgIHJlY29yZERlbGltaXRlck1heExlbmd0aCA9PT0gMCA/IEJ1ZmZlci5mcm9tKCdcXHJcXG4nLCBlbmNvZGluZykubGVuZ3RoIDogcmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoLFxuICAgICAgICAvLyBTa2lwIGlmIHJlbWFpbmluZyBidWZmZXIgY2FuIGJlIGFuIGVzY2FwZWQgcXVvdGVcbiAgICAgICAgcXVvdGluZyA/ICgoZXNjYXBlID09PSBudWxsID8gMCA6IGVzY2FwZS5sZW5ndGgpICsgcXVvdGUubGVuZ3RoKSA6IDAsXG4gICAgICAgIC8vIFNraXAgaWYgcmVtYWluaW5nIGJ1ZmZlciBjYW4gYmUgcmVjb3JkIGRlbGltaXRlciBmb2xsb3dpbmcgdGhlIGNsb3NpbmcgcXVvdGVcbiAgICAgICAgcXVvdGluZyA/IChxdW90ZS5sZW5ndGggKyByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGgpIDogMCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVtT2ZDaGFyTGVmdCA8IHJlcXVpcmVkTGVuZ3RoO1xuICAgIH0sXG4gICAgLy8gQ2VudHJhbCBwYXJzZXIgaW1wbGVtZW50YXRpb25cbiAgICBwYXJzZTogZnVuY3Rpb24obmV4dEJ1ZiwgZW5kLCBwdXNoLCBjbG9zZSl7XG4gICAgICBjb25zdCB7Ym9tLCBlbmNvZGluZywgZnJvbV9saW5lLCBsdHJpbSwgbWF4X3JlY29yZF9zaXplLHJhdywgcmVsYXhfcXVvdGVzLCBydHJpbSwgc2tpcF9lbXB0eV9saW5lcywgdG8sIHRvX2xpbmV9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgbGV0IHtjb21tZW50LCBlc2NhcGUsIHF1b3RlLCByZWNvcmRfZGVsaW1pdGVyfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGNvbnN0IHtib21Ta2lwcGVkLCBwcmV2aW91c0J1ZiwgcmF3QnVmZmVyLCBlc2NhcGVJc1F1b3RlfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQgYnVmO1xuICAgICAgaWYocHJldmlvdXNCdWYgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIGlmKG5leHRCdWYgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgLy8gSGFuZGxlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgYnVmID0gbmV4dEJ1ZjtcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYocHJldmlvdXNCdWYgIT09IHVuZGVmaW5lZCAmJiBuZXh0QnVmID09PSB1bmRlZmluZWQpe1xuICAgICAgICBidWYgPSBwcmV2aW91c0J1ZjtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbcHJldmlvdXNCdWYsIG5leHRCdWZdKTtcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBVVEYgQk9NXG4gICAgICBpZihib21Ta2lwcGVkID09PSBmYWxzZSl7XG4gICAgICAgIGlmKGJvbSA9PT0gZmFsc2Upe1xuICAgICAgICAgIHRoaXMuc3RhdGUuYm9tU2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH1lbHNlIGlmKGJ1Zi5sZW5ndGggPCAzKXtcbiAgICAgICAgICAvLyBObyBlbm91Z2ggZGF0YVxuICAgICAgICAgIGlmKGVuZCA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzQnVmID0gYnVmO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIGZvcihjb25zdCBlbmNvZGluZyBpbiBib21zKXtcbiAgICAgICAgICAgIGlmKGJvbXNbZW5jb2RpbmddLmNvbXBhcmUoYnVmLCAwLCBib21zW2VuY29kaW5nXS5sZW5ndGgpID09PSAwKXtcbiAgICAgICAgICAgICAgLy8gU2tpcCBCT01cbiAgICAgICAgICAgICAgY29uc3QgYm9tTGVuZ3RoID0gYm9tc1tlbmNvZGluZ10ubGVuZ3RoO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKz0gYm9tTGVuZ3RoO1xuICAgICAgICAgICAgICBidWYgPSBidWYuc2xpY2UoYm9tTGVuZ3RoKTtcbiAgICAgICAgICAgICAgLy8gUmVub3JtYWxpemUgb3JpZ2luYWwgb3B0aW9ucyB3aXRoIHRoZSBuZXcgZW5jb2RpbmdcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbm9ybWFsaXplX29wdGlvbnMkMSh7Li4udGhpcy5vcmlnaW5hbF9vcHRpb25zLCBlbmNvZGluZzogZW5jb2Rpbmd9KTtcbiAgICAgICAgICAgICAgLy8gT3B0aW9ucyB3aWxsIHJlLWV2YWx1YXRlIHRoZSBCdWZmZXIgd2l0aCB0aGUgbmV3IGVuY29kaW5nXG4gICAgICAgICAgICAgICh7Y29tbWVudCwgZXNjYXBlLCBxdW90ZSB9ID0gdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUuYm9tU2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZkxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICBsZXQgcG9zO1xuICAgICAgZm9yKHBvcyA9IDA7IHBvcyA8IGJ1ZkxlbjsgcG9zKyspe1xuICAgICAgICAvLyBFbnN1cmUgd2UgZ2V0IGVub3VnaCBzcGFjZSB0byBsb29rIGFoZWFkXG4gICAgICAgIC8vIFRoZXJlIHNob3VsZCBiZSBhIHdheSB0byBtb3ZlIHRoaXMgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgIGlmKHRoaXMuX19uZWVkTW9yZURhdGEocG9zLCBidWZMZW4sIGVuZCkpe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID09PSB0cnVlKXtcbiAgICAgICAgICB0aGlzLmluZm8ubGluZXMrKztcbiAgICAgICAgICB0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRvX2xpbmUgIT09IC0xICYmIHRoaXMuaW5mby5saW5lcyA+IHRvX2xpbmUpe1xuICAgICAgICAgIHRoaXMuc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXV0byBkaXNjb3Zlcnkgb2YgcmVjb3JkX2RlbGltaXRlciwgdW5peCwgbWFjIGFuZCB3aW5kb3dzIHN1cHBvcnRlZFxuICAgICAgICBpZih0aGlzLnN0YXRlLnF1b3RpbmcgPT09IGZhbHNlICYmIHJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICBjb25zdCByZWNvcmRfZGVsaW1pdGVyQ291bnQgPSB0aGlzLl9fYXV0b0Rpc2NvdmVyUmVjb3JkRGVsaW1pdGVyKGJ1ZiwgcG9zKTtcbiAgICAgICAgICBpZihyZWNvcmRfZGVsaW1pdGVyQ291bnQpe1xuICAgICAgICAgICAgcmVjb3JkX2RlbGltaXRlciA9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHIgPSBidWZbcG9zXTtcbiAgICAgICAgaWYocmF3ID09PSB0cnVlKXtcbiAgICAgICAgICByYXdCdWZmZXIuYXBwZW5kKGNocik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoKGNociA9PT0gY3IgfHwgY2hyID09PSBubCkgJiYgdGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IGZhbHNlKXtcbiAgICAgICAgICB0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmlvdXMgY2hhciB3YXMgYSB2YWxpZCBlc2NhcGUgY2hhclxuICAgICAgICAvLyB0cmVhdCB0aGUgY3VycmVudCBjaGFyIGFzIGEgcmVndWxhciBjaGFyXG4gICAgICAgIGlmKHRoaXMuc3RhdGUuZXNjYXBpbmcgPT09IHRydWUpe1xuICAgICAgICAgIHRoaXMuc3RhdGUuZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIC8vIEVzY2FwZSBpcyBvbmx5IGFjdGl2ZSBpbnNpZGUgcXVvdGVkIGZpZWxkc1xuICAgICAgICAgIC8vIFdlIGFyZSBxdW90aW5nLCB0aGUgY2hhciBpcyBhbiBlc2NhcGUgY2hyIGFuZCB0aGVyZSBpcyBhIGNociB0byBlc2NhcGVcbiAgICAgICAgICAvLyBpZihlc2NhcGUgIT09IG51bGwgJiYgdGhpcy5zdGF0ZS5xdW90aW5nID09PSB0cnVlICYmIGNociA9PT0gZXNjYXBlICYmIHBvcyArIDEgPCBidWZMZW4pe1xuICAgICAgICAgIGlmKGVzY2FwZSAhPT0gbnVsbCAmJiB0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUgJiYgdGhpcy5fX2lzRXNjYXBlKGJ1ZiwgcG9zLCBjaHIpICYmIHBvcyArIGVzY2FwZS5sZW5ndGggPCBidWZMZW4pe1xuICAgICAgICAgICAgaWYoZXNjYXBlSXNRdW90ZSl7XG4gICAgICAgICAgICAgIGlmKHRoaXMuX19pc1F1b3RlKGJ1ZiwgcG9zK2VzY2FwZS5sZW5ndGgpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmVzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gZXNjYXBlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5lc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcyArPSBlc2NhcGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdCBjdXJyZW50bHkgZXNjYXBpbmcgYW5kIGNociBpcyBhIHF1b3RlXG4gICAgICAgICAgLy8gVE9ETzogbmVlZCB0byBjb21wYXJlIGJ5dGVzIGluc3RlYWQgb2Ygc2luZ2xlIGNoYXJcbiAgICAgICAgICBpZih0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPT09IGZhbHNlICYmIHRoaXMuX19pc1F1b3RlKGJ1ZiwgcG9zKSl7XG4gICAgICAgICAgICBpZih0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUpe1xuICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hyID0gYnVmW3BvcytxdW90ZS5sZW5ndGhdO1xuICAgICAgICAgICAgICBjb25zdCBpc05leHRDaHJUcmltYWJsZSA9IHJ0cmltICYmIHRoaXMuX19pc0NoYXJUcmltYWJsZShidWYsIHBvcytxdW90ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICBjb25zdCBpc05leHRDaHJDb21tZW50ID0gY29tbWVudCAhPT0gbnVsbCAmJiB0aGlzLl9fY29tcGFyZUJ5dGVzKGNvbW1lbnQsIGJ1ZiwgcG9zK3F1b3RlLmxlbmd0aCwgbmV4dENocik7XG4gICAgICAgICAgICAgIGNvbnN0IGlzTmV4dENockRlbGltaXRlciA9IHRoaXMuX19pc0RlbGltaXRlcihidWYsIHBvcytxdW90ZS5sZW5ndGgsIG5leHRDaHIpO1xuICAgICAgICAgICAgICBjb25zdCBpc05leHRDaHJSZWNvcmREZWxpbWl0ZXIgPSByZWNvcmRfZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCA/IHRoaXMuX19hdXRvRGlzY292ZXJSZWNvcmREZWxpbWl0ZXIoYnVmLCBwb3MrcXVvdGUubGVuZ3RoKSA6IHRoaXMuX19pc1JlY29yZERlbGltaXRlcihuZXh0Q2hyLCBidWYsIHBvcytxdW90ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAvLyBFc2NhcGUgYSBxdW90ZVxuICAgICAgICAgICAgICAvLyBUcmVhdCBuZXh0IGNoYXIgYXMgYSByZWd1bGFyIGNoYXJhY3RlclxuICAgICAgICAgICAgICBpZihlc2NhcGUgIT09IG51bGwgJiYgdGhpcy5fX2lzRXNjYXBlKGJ1ZiwgcG9zLCBjaHIpICYmIHRoaXMuX19pc1F1b3RlKGJ1ZiwgcG9zICsgZXNjYXBlLmxlbmd0aCkpe1xuICAgICAgICAgICAgICAgIHBvcyArPSBlc2NhcGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgfWVsc2UgaWYoIW5leHRDaHIgfHwgaXNOZXh0Q2hyRGVsaW1pdGVyIHx8IGlzTmV4dENoclJlY29yZERlbGltaXRlciB8fCBpc05leHRDaHJDb21tZW50IHx8IGlzTmV4dENoclRyaW1hYmxlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnF1b3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcyArPSBxdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9ZWxzZSBpZihyZWxheF9xdW90ZXMgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgICAgICAgICBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfQ0xPU0lOR19RVU9URScsIFtcbiAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgQ2xvc2luZyBRdW90ZTonLFxuICAgICAgICAgICAgICAgICAgICBgZ290IFwiJHtTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaHIpfVwiYCxcbiAgICAgICAgICAgICAgICAgICAgYGF0IGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgICAgICAgICAgJ2luc3RlYWQgb2YgZGVsaW1pdGVyLCByZWNvcmQgZGVsaW1pdGVyLCB0cmltYWJsZSBjaGFyYWN0ZXInLFxuICAgICAgICAgICAgICAgICAgICAnKGlmIGFjdGl2YXRlZCkgb3IgY29tbWVudCcsXG4gICAgICAgICAgICAgICAgICBdLCB0aGlzLm9wdGlvbnMsIHRoaXMuX19pbmZvRmllbGQoKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5xdW90aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS53YXNRdW90aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmZpZWxkLnByZXBlbmQocXVvdGUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBxdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoICE9PSAwKXtcbiAgICAgICAgICAgICAgICAvLyBJbiByZWxheF9xdW90ZXMgbW9kZSwgdHJlYXQgb3BlbmluZyBxdW90ZSBwcmVjZWRlZCBieSBjaHJzIGFzIHJlZ3VsYXJcbiAgICAgICAgICAgICAgICBpZihyZWxheF9xdW90ZXMgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9faW5mb0ZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBib20gPSBPYmplY3Qua2V5cyhib21zKS5tYXAoYiA9PiBib21zW2JdLmVxdWFscyh0aGlzLnN0YXRlLmZpZWxkLnRvU3RyaW5nKCkpID8gYiA6IGZhbHNlKS5maWx0ZXIoQm9vbGVhbilbMF07XG4gICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDc3ZFcnJvciQxKCdJTlZBTElEX09QRU5JTkdfUVVPVEUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgT3BlbmluZyBRdW90ZTonLFxuICAgICAgICAgICAgICAgICAgICAgIGBhIHF1b3RlIGlzIGZvdW5kIG9uIGZpZWxkICR7SlNPTi5zdHJpbmdpZnkoaW5mby5jb2x1bW4pfSBhdCBsaW5lICR7aW5mby5saW5lc30sIHZhbHVlIGlzICR7SlNPTi5zdHJpbmdpZnkodGhpcy5zdGF0ZS5maWVsZC50b1N0cmluZyhlbmNvZGluZykpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgYm9tID8gYCgke2JvbX0gYm9tKWAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5vcHRpb25zLCBpbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRoaXMuc3RhdGUuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYoZXJyICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5xdW90aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gcXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLnN0YXRlLnF1b3RpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZERlbGltaXRlckxlbmd0aCA9IHRoaXMuX19pc1JlY29yZERlbGltaXRlcihjaHIsIGJ1ZiwgcG9zKTtcbiAgICAgICAgICAgIGlmKHJlY29yZERlbGltaXRlckxlbmd0aCAhPT0gMCl7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBlbWl0IGNvbW1lbnRzIHdoaWNoIHRha2UgYSBmdWxsIGxpbmVcbiAgICAgICAgICAgICAgY29uc3Qgc2tpcENvbW1lbnRMaW5lID0gdGhpcy5zdGF0ZS5jb21tZW50aW5nICYmICh0aGlzLnN0YXRlLndhc1F1b3RpbmcgPT09IGZhbHNlICYmIHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgICAgICAgIGlmKHNraXBDb21tZW50TGluZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmNvbW1lbnRfbGluZXMrKztcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGZ1bGwgY29tbWVudCBsaW5lXG4gICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBY3RpdmF0ZSByZWNvcmRzIGVtaXRpb24gaWYgYWJvdmUgZnJvbV9saW5lXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZS5lbmFibGVkID09PSBmYWxzZSAmJiB0aGlzLmluZm8ubGluZXMgKyAodGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IHRydWUgPyAxOiAwKSA+PSBmcm9tX2xpbmUpe1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX19yZXNldEZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKTtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSByZWNvcmREZWxpbWl0ZXJMZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNraXAgaWYgbGluZSBpcyBlbXB0eSBhbmQgc2tpcF9lbXB0eV9saW5lcyBhY3RpdmF0ZWRcbiAgICAgICAgICAgICAgICBpZihza2lwX2VtcHR5X2xpbmVzID09PSB0cnVlICYmIHRoaXMuc3RhdGUud2FzUXVvdGluZyA9PT0gZmFsc2UgJiYgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoID09PSAwICYmIHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5mby5lbXB0eV9saW5lcysrO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHJlY29yZERlbGltaXRlckxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmJ5dGVzID0gdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICsgcG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyckZpZWxkID0gdGhpcy5fX29uRmllbGQoKTtcbiAgICAgICAgICAgICAgICBpZihlcnJGaWVsZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyRmllbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmJ5dGVzID0gdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICsgcG9zICsgcmVjb3JkRGVsaW1pdGVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyclJlY29yZCA9IHRoaXMuX19vblJlY29yZChwdXNoKTtcbiAgICAgICAgICAgICAgICBpZihlcnJSZWNvcmQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyclJlY29yZDtcbiAgICAgICAgICAgICAgICBpZih0byAhPT0gLTEgJiYgdGhpcy5pbmZvLnJlY29yZHMgPj0gdG8pe1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuY29tbWVudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBwb3MgKz0gcmVjb3JkRGVsaW1pdGVyTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLnN0YXRlLmNvbW1lbnRpbmcpe1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRDb3VudCA9IGNvbW1lbnQgPT09IG51bGwgPyAwIDogdGhpcy5fX2NvbXBhcmVCeXRlcyhjb21tZW50LCBidWYsIHBvcywgY2hyKTtcbiAgICAgICAgICAgIGlmKGNvbW1lbnRDb3VudCAhPT0gMCl7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuY29tbWVudGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsaW1pdGVyTGVuZ3RoID0gdGhpcy5fX2lzRGVsaW1pdGVyKGJ1ZiwgcG9zLCBjaHIpO1xuICAgICAgICAgICAgaWYoZGVsaW1pdGVyTGVuZ3RoICE9PSAwKXtcbiAgICAgICAgICAgICAgdGhpcy5pbmZvLmJ5dGVzID0gdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICsgcG9zO1xuICAgICAgICAgICAgICBjb25zdCBlcnJGaWVsZCA9IHRoaXMuX19vbkZpZWxkKCk7XG4gICAgICAgICAgICAgIGlmKGVyckZpZWxkICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJGaWVsZDtcbiAgICAgICAgICAgICAgcG9zICs9IGRlbGltaXRlckxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgICBpZihtYXhfcmVjb3JkX3NpemUgIT09IDAgJiYgdGhpcy5zdGF0ZS5yZWNvcmRfbGVuZ3RoICsgdGhpcy5zdGF0ZS5maWVsZC5sZW5ndGggPiBtYXhfcmVjb3JkX3NpemUpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgICAgbmV3IENzdkVycm9yJDEoJ0NTVl9NQVhfUkVDT1JEX1NJWkUnLCBbXG4gICAgICAgICAgICAgICAgJ01heCBSZWNvcmQgU2l6ZTonLFxuICAgICAgICAgICAgICAgICdyZWNvcmQgZXhjZWVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2xlcmF0ZWQgYnl0ZXMnLFxuICAgICAgICAgICAgICAgIGBvZiAke21heF9yZWNvcmRfc2l6ZX1gLFxuICAgICAgICAgICAgICAgIGBhdCBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFwcGVuZCA9IGx0cmltID09PSBmYWxzZSB8fCB0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUgfHwgdGhpcy5zdGF0ZS5maWVsZC5sZW5ndGggIT09IDAgfHwgIXRoaXMuX19pc0NoYXJUcmltYWJsZShidWYsIHBvcyk7XG4gICAgICAgIC8vIHJ0cmltIGluIG5vbiBxdW90aW5nIGlzIGhhbmRsZSBpbiBfX29uRmllbGRcbiAgICAgICAgY29uc3QgcmFwcGVuZCA9IHJ0cmltID09PSBmYWxzZSB8fCB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPT09IGZhbHNlO1xuICAgICAgICBpZihsYXBwZW5kID09PSB0cnVlICYmIHJhcHBlbmQgPT09IHRydWUpe1xuICAgICAgICAgIHRoaXMuc3RhdGUuZmllbGQuYXBwZW5kKGNocik7XG4gICAgICAgIH1lbHNlIGlmKHJ0cmltID09PSB0cnVlICYmICF0aGlzLl9faXNDaGFyVHJpbWFibGUoYnVmLCBwb3MpKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2Vycm9yKFxuICAgICAgICAgICAgbmV3IENzdkVycm9yJDEoJ0NTVl9OT05fVFJJTUFCTEVfQ0hBUl9BRlRFUl9DTE9TSU5HX1FVT1RFJywgW1xuICAgICAgICAgICAgICAnSW52YWxpZCBDbG9zaW5nIFF1b3RlOicsXG4gICAgICAgICAgICAgICdmb3VuZCBub24gdHJpbWFibGUgYnl0ZSBhZnRlciBxdW90ZScsXG4gICAgICAgICAgICAgIGBhdCBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgICAgICBdLCB0aGlzLm9wdGlvbnMsIHRoaXMuX19pbmZvRmllbGQoKSlcbiAgICAgICAgICApO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgaWYobGFwcGVuZCA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgcG9zICs9IHRoaXMuX19pc0NoYXJUcmltYWJsZShidWYsIHBvcykgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoZW5kID09PSB0cnVlKXtcbiAgICAgICAgLy8gRW5zdXJlIHdlIGFyZSBub3QgZW5kaW5nIGluIGEgcXVvdGluZyBzdGF0ZVxuICAgICAgICBpZih0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUpe1xuICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19lcnJvcihcbiAgICAgICAgICAgIG5ldyBDc3ZFcnJvciQxKCdDU1ZfUVVPVEVfTk9UX0NMT1NFRCcsIFtcbiAgICAgICAgICAgICAgJ1F1b3RlIE5vdCBDbG9zZWQ6JyxcbiAgICAgICAgICAgICAgYHRoZSBwYXJzaW5nIGlzIGZpbmlzaGVkIHdpdGggYW4gb3BlbmluZyBxdW90ZSBhdCBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgICAgICBdLCB0aGlzLm9wdGlvbnMsIHRoaXMuX19pbmZvRmllbGQoKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgLy8gU2tpcCBsYXN0IGxpbmUgaWYgaXQgaGFzIG5vIGNoYXJhY3RlcnNcbiAgICAgICAgICBpZih0aGlzLnN0YXRlLndhc1F1b3RpbmcgPT09IHRydWUgfHwgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoICE9PSAwIHx8IHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoICE9PSAwKXtcbiAgICAgICAgICAgIHRoaXMuaW5mby5ieXRlcyA9IHRoaXMuc3RhdGUuYnVmQnl0ZXNTdGFydCArIHBvcztcbiAgICAgICAgICAgIGNvbnN0IGVyckZpZWxkID0gdGhpcy5fX29uRmllbGQoKTtcbiAgICAgICAgICAgIGlmKGVyckZpZWxkICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJGaWVsZDtcbiAgICAgICAgICAgIGNvbnN0IGVyclJlY29yZCA9IHRoaXMuX19vblJlY29yZChwdXNoKTtcbiAgICAgICAgICAgIGlmKGVyclJlY29yZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyUmVjb3JkO1xuICAgICAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID09PSB0cnVlKXtcbiAgICAgICAgICAgIHRoaXMuaW5mby5lbXB0eV9saW5lcysrO1xuICAgICAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUuY29tbWVudGluZyA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICB0aGlzLmluZm8uY29tbWVudF9saW5lcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKz0gcG9zO1xuICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzQnVmID0gYnVmLnNsaWNlKHBvcyk7XG4gICAgICB9XG4gICAgICBpZih0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9PT0gdHJ1ZSl7XG4gICAgICAgIHRoaXMuaW5mby5saW5lcysrO1xuICAgICAgICB0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgX19vblJlY29yZDogZnVuY3Rpb24ocHVzaCl7XG4gICAgICBjb25zdCB7Y29sdW1ucywgZ3JvdXBfY29sdW1uc19ieV9uYW1lLCBlbmNvZGluZywgaW5mbywgZnJvbSwgcmVsYXhfY29sdW1uX2NvdW50LCByZWxheF9jb2x1bW5fY291bnRfbGVzcywgcmVsYXhfY29sdW1uX2NvdW50X21vcmUsIHJhdywgc2tpcF9yZWNvcmRzX3dpdGhfZW1wdHlfdmFsdWVzfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGNvbnN0IHtlbmFibGVkLCByZWNvcmR9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmKGVuYWJsZWQgPT09IGZhbHNlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19yZXNldFJlY29yZCgpO1xuICAgICAgfVxuICAgICAgLy8gQ29udmVydCB0aGUgZmlyc3QgbGluZSBpbnRvIGNvbHVtbiBuYW1lc1xuICAgICAgY29uc3QgcmVjb3JkTGVuZ3RoID0gcmVjb3JkLmxlbmd0aDtcbiAgICAgIGlmKGNvbHVtbnMgPT09IHRydWUpe1xuICAgICAgICBpZihza2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHRydWUgJiYgaXNSZWNvcmRFbXB0eShyZWNvcmQpKXtcbiAgICAgICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19maXJzdExpbmVUb0NvbHVtbnMocmVjb3JkKTtcbiAgICAgIH1cbiAgICAgIGlmKGNvbHVtbnMgPT09IGZhbHNlICYmIHRoaXMuaW5mby5yZWNvcmRzID09PSAwKXtcbiAgICAgICAgdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCA9IHJlY29yZExlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmKHJlY29yZExlbmd0aCAhPT0gdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCl7XG4gICAgICAgIGNvbnN0IGVyciA9IGNvbHVtbnMgPT09IGZhbHNlID9cbiAgICAgICAgICBuZXcgQ3N2RXJyb3IkMSgnQ1NWX1JFQ09SRF9JTkNPTlNJU1RFTlRfRklFTERTX0xFTkdUSCcsIFtcbiAgICAgICAgICAgICdJbnZhbGlkIFJlY29yZCBMZW5ndGg6JyxcbiAgICAgICAgICAgIGBleHBlY3QgJHt0aGlzLnN0YXRlLmV4cGVjdGVkUmVjb3JkTGVuZ3RofSxgLFxuICAgICAgICAgICAgYGdvdCAke3JlY29yZExlbmd0aH0gb24gbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpLCB7XG4gICAgICAgICAgICByZWNvcmQ6IHJlY29yZCxcbiAgICAgICAgICB9KVxuICAgICAgICAgIDpcbiAgICAgICAgICBuZXcgQ3N2RXJyb3IkMSgnQ1NWX1JFQ09SRF9JTkNPTlNJU1RFTlRfQ09MVU1OUycsIFtcbiAgICAgICAgICAgICdJbnZhbGlkIFJlY29yZCBMZW5ndGg6JyxcbiAgICAgICAgICAgIGBjb2x1bW5zIGxlbmd0aCBpcyAke2NvbHVtbnMubGVuZ3RofSxgLCAvLyByZW5hbWUgY29sdW1uc1xuICAgICAgICAgICAgYGdvdCAke3JlY29yZExlbmd0aH0gb24gbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpLCB7XG4gICAgICAgICAgICByZWNvcmQ6IHJlY29yZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYocmVsYXhfY29sdW1uX2NvdW50ID09PSB0cnVlIHx8XG4gICAgICAgICAgKHJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID09PSB0cnVlICYmIHJlY29yZExlbmd0aCA8IHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGgpIHx8XG4gICAgICAgICAgKHJlbGF4X2NvbHVtbl9jb3VudF9tb3JlID09PSB0cnVlICYmIHJlY29yZExlbmd0aCA+IHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGgpKXtcbiAgICAgICAgICB0aGlzLmluZm8uaW52YWxpZF9maWVsZF9sZW5ndGgrKztcbiAgICAgICAgICB0aGlzLnN0YXRlLmVycm9yID0gZXJyO1xuICAgICAgICAvLyBFcnJvciBpcyB1bmRlZmluZWQgd2l0aCBza2lwX3JlY29yZHNfd2l0aF9lcnJvclxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmluYWxFcnIgPSB0aGlzLl9fZXJyb3IoZXJyKTtcbiAgICAgICAgICBpZihmaW5hbEVycikgcmV0dXJuIGZpbmFsRXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihza2lwX3JlY29yZHNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHRydWUgJiYgaXNSZWNvcmRFbXB0eShyZWNvcmQpKXtcbiAgICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuc3RhdGUucmVjb3JkSGFzRXJyb3IgPT09IHRydWUpe1xuICAgICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmRIYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmluZm8ucmVjb3JkcysrO1xuICAgICAgaWYoZnJvbSA9PT0gMSB8fCB0aGlzLmluZm8ucmVjb3JkcyA+PSBmcm9tKXtcbiAgICAgICAgY29uc3Qge29iam5hbWV9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBXaXRoIGNvbHVtbnMsIHJlY29yZHMgYXJlIG9iamVjdFxuICAgICAgICBpZihjb2x1bW5zICE9PSBmYWxzZSl7XG4gICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY29yZCBhcnJheSB0byBhbiBvYmplY3RcbiAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsID0gcmVjb3JkLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG4gICAgICAgICAgICBpZihjb2x1bW5zW2ldID09PSB1bmRlZmluZWQgfHwgY29sdW1uc1tpXS5kaXNhYmxlZCkgY29udGludWU7XG4gICAgICAgICAgICAvLyBUdXJuIGR1cGxpY2F0ZSBjb2x1bW5zIGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChncm91cF9jb2x1bW5zX2J5X25hbWUgPT09IHRydWUgJiYgb2JqW2NvbHVtbnNbaV0ubmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpbY29sdW1uc1tpXS5uYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBvYmpbY29sdW1uc1tpXS5uYW1lXSA9IG9ialtjb2x1bW5zW2ldLm5hbWVdLmNvbmNhdChyZWNvcmRbaV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtjb2x1bW5zW2ldLm5hbWVdID0gW29ialtjb2x1bW5zW2ldLm5hbWVdLCByZWNvcmRbaV1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmpbY29sdW1uc1tpXS5uYW1lXSA9IHJlY29yZFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gV2l0aG91dCBvYmpuYW1lIChkZWZhdWx0KVxuICAgICAgICAgIGlmKHJhdyA9PT0gdHJ1ZSB8fCBpbmZvID09PSB0cnVlKXtcbiAgICAgICAgICAgIGNvbnN0IGV4dFJlY29yZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHtyZWNvcmQ6IG9ian0sXG4gICAgICAgICAgICAgIChyYXcgPT09IHRydWUgPyB7cmF3OiB0aGlzLnN0YXRlLnJhd0J1ZmZlci50b1N0cmluZyhlbmNvZGluZyl9OiB7fSksXG4gICAgICAgICAgICAgIChpbmZvID09PSB0cnVlID8ge2luZm86IHRoaXMuX19pbmZvUmVjb3JkKCl9OiB7fSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChcbiAgICAgICAgICAgICAgb2JqbmFtZSA9PT0gdW5kZWZpbmVkID8gZXh0UmVjb3JkIDogW29ialtvYmpuYW1lXSwgZXh0UmVjb3JkXVxuICAgICAgICAgICAgICAsIHB1c2gpO1xuICAgICAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChcbiAgICAgICAgICAgICAgb2JqbmFtZSA9PT0gdW5kZWZpbmVkID8gb2JqIDogW29ialtvYmpuYW1lXSwgb2JqXVxuICAgICAgICAgICAgICAsIHB1c2gpO1xuICAgICAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIFdpdGhvdXQgY29sdW1ucywgcmVjb3JkcyBhcmUgYXJyYXlcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIGlmKHJhdyA9PT0gdHJ1ZSB8fCBpbmZvID09PSB0cnVlKXtcbiAgICAgICAgICAgIGNvbnN0IGV4dFJlY29yZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHtyZWNvcmQ6IHJlY29yZH0sXG4gICAgICAgICAgICAgIHJhdyA9PT0gdHJ1ZSA/IHtyYXc6IHRoaXMuc3RhdGUucmF3QnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKX06IHt9LFxuICAgICAgICAgICAgICBpbmZvID09PSB0cnVlID8ge2luZm86IHRoaXMuX19pbmZvUmVjb3JkKCl9OiB7fVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19wdXNoKFxuICAgICAgICAgICAgICBvYmpuYW1lID09PSB1bmRlZmluZWQgPyBleHRSZWNvcmQgOiBbcmVjb3JkW29iam5hbWVdLCBleHRSZWNvcmRdXG4gICAgICAgICAgICAgICwgcHVzaCk7XG4gICAgICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX19wdXNoKFxuICAgICAgICAgICAgICBvYmpuYW1lID09PSB1bmRlZmluZWQgPyByZWNvcmQgOiBbcmVjb3JkW29iam5hbWVdLCByZWNvcmRdXG4gICAgICAgICAgICAgICwgcHVzaCk7XG4gICAgICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKCk7XG4gICAgfSxcbiAgICBfX2ZpcnN0TGluZVRvQ29sdW1uczogZnVuY3Rpb24ocmVjb3JkKXtcbiAgICAgIGNvbnN0IHtmaXJzdExpbmVUb0hlYWRlcnN9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGZpcnN0TGluZVRvSGVhZGVycyA9PT0gdW5kZWZpbmVkID8gcmVjb3JkIDogZmlyc3RMaW5lVG9IZWFkZXJzLmNhbGwobnVsbCwgcmVjb3JkKTtcbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkoaGVhZGVycykpe1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgICBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfQ09MVU1OX01BUFBJTkcnLCBbXG4gICAgICAgICAgICAgICdJbnZhbGlkIENvbHVtbiBNYXBwaW5nOicsXG4gICAgICAgICAgICAgICdleHBlY3QgYW4gYXJyYXkgZnJvbSBjb2x1bW4gZnVuY3Rpb24sJyxcbiAgICAgICAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KGhlYWRlcnMpfWBcbiAgICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpLCB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSBub3JtYWxpemVfY29sdW1uc19hcnJheShoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCA9IG5vcm1hbGl6ZWRIZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbnMgPSBub3JtYWxpemVkSGVhZGVycztcbiAgICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgX19yZXNldFJlY29yZDogZnVuY3Rpb24oKXtcbiAgICAgIGlmKHRoaXMub3B0aW9ucy5yYXcgPT09IHRydWUpe1xuICAgICAgICB0aGlzLnN0YXRlLnJhd0J1ZmZlci5yZXNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc3RhdGUucmVjb3JkID0gW107XG4gICAgICB0aGlzLnN0YXRlLnJlY29yZF9sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgX19vbkZpZWxkOiBmdW5jdGlvbigpe1xuICAgICAgY29uc3Qge2Nhc3QsIGVuY29kaW5nLCBydHJpbSwgbWF4X3JlY29yZF9zaXplfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGNvbnN0IHtlbmFibGVkLCB3YXNRdW90aW5nfSA9IHRoaXMuc3RhdGU7XG4gICAgICAvLyBTaG9ydCBjaXJjdWl0IGZvciB0aGUgZnJvbV9saW5lIG9wdGlvbnNcbiAgICAgIGlmKGVuYWJsZWQgPT09IGZhbHNlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19yZXNldEZpZWxkKCk7XG4gICAgICB9XG4gICAgICBsZXQgZmllbGQgPSB0aGlzLnN0YXRlLmZpZWxkLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgIGlmKHJ0cmltID09PSB0cnVlICYmIHdhc1F1b3RpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgZmllbGQgPSBmaWVsZC50cmltUmlnaHQoKTtcbiAgICAgIH1cbiAgICAgIGlmKGNhc3QgPT09IHRydWUpe1xuICAgICAgICBjb25zdCBbZXJyLCBmXSA9IHRoaXMuX19jYXN0KGZpZWxkKTtcbiAgICAgICAgaWYoZXJyICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnI7XG4gICAgICAgIGZpZWxkID0gZjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUucmVjb3JkLnB1c2goZmllbGQpO1xuICAgICAgLy8gSW5jcmVtZW50IHJlY29yZCBsZW5ndGggaWYgcmVjb3JkIHNpemUgbXVzdCBub3QgZXhjZWVkIGEgbGltaXRcbiAgICAgIGlmKG1heF9yZWNvcmRfc2l6ZSAhPT0gMCAmJiB0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmRfbGVuZ3RoICs9IGZpZWxkLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19yZXNldEZpZWxkKCk7XG4gICAgfSxcbiAgICBfX3Jlc2V0RmllbGQ6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnN0YXRlLmZpZWxkLnJlc2V0KCk7XG4gICAgICB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIF9fcHVzaDogZnVuY3Rpb24ocmVjb3JkLCBwdXNoKXtcbiAgICAgIGNvbnN0IHtvbl9yZWNvcmR9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYob25fcmVjb3JkICE9PSB1bmRlZmluZWQpe1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5fX2luZm9SZWNvcmQoKTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIHJlY29yZCA9IG9uX3JlY29yZC5jYWxsKG51bGwsIHJlY29yZCwgaW5mbyk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocmVjb3JkID09PSB1bmRlZmluZWQgfHwgcmVjb3JkID09PSBudWxsKXsgcmV0dXJuOyB9XG4gICAgICB9XG4gICAgICBwdXNoKHJlY29yZCk7XG4gICAgfSxcbiAgICAvLyBSZXR1cm4gYSB0dXBsZSB3aXRoIHRoZSBlcnJvciBhbmQgdGhlIGNhc3RlZCB2YWx1ZVxuICAgIF9fY2FzdDogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgY29uc3Qge2NvbHVtbnMsIHJlbGF4X2NvbHVtbl9jb3VudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCBpc0NvbHVtbnMgPSBBcnJheS5pc0FycmF5KGNvbHVtbnMpO1xuICAgICAgLy8gRG9udCBsb29zZSB0aW1lIGNhbGxpbmcgY2FzdFxuICAgICAgLy8gYmVjYXVzZSB0aGUgZmluYWwgcmVjb3JkIGlzIGFuIG9iamVjdFxuICAgICAgLy8gYW5kIHRoaXMgZmllbGQgY2FuJ3QgYmUgYXNzb2NpYXRlZCB0byBhIGtleSBwcmVzZW50IGluIGNvbHVtbnNcbiAgICAgIGlmKGlzQ29sdW1ucyA9PT0gdHJ1ZSAmJiByZWxheF9jb2x1bW5fY291bnQgJiYgdGhpcy5vcHRpb25zLmNvbHVtbnMubGVuZ3RoIDw9IHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCl7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xuICAgICAgfVxuICAgICAgaWYodGhpcy5zdGF0ZS5jYXN0RmllbGQgIT09IG51bGwpe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX19pbmZvRmllbGQoKTtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5zdGF0ZS5jYXN0RmllbGQuY2FsbChudWxsLCBmaWVsZCwgaW5mbyldO1xuICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuX19pc0Zsb2F0KGZpZWxkKSl7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBwYXJzZUZsb2F0KGZpZWxkKV07XG4gICAgICB9ZWxzZSBpZih0aGlzLm9wdGlvbnMuY2FzdF9kYXRlICE9PSBmYWxzZSl7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9faW5mb0ZpZWxkKCk7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMuY2FzdF9kYXRlLmNhbGwobnVsbCwgZmllbGQsIGluZm8pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBmaWVsZF07XG4gICAgfSxcbiAgICAvLyBIZWxwZXIgdG8gdGVzdCBpZiBhIGNoYXJhY3RlciBpcyBhIHNwYWNlIG9yIGEgbGluZSBkZWxpbWl0ZXJcbiAgICBfX2lzQ2hhclRyaW1hYmxlOiBmdW5jdGlvbihidWYsIHBvcyl7XG4gICAgICBjb25zdCBpc1RyaW0gPSAoYnVmLCBwb3MpID0+IHtcbiAgICAgICAgY29uc3Qge3RpbWNoYXJzfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxvb3AxOiBmb3IobGV0IGkgPSAwOyBpIDwgdGltY2hhcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGNvbnN0IHRpbWNoYXIgPSB0aW1jaGFyc1tpXTtcbiAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGltY2hhci5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICBpZih0aW1jaGFyW2pdICE9PSBidWZbcG9zK2pdKSBjb250aW51ZSBsb29wMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRpbWNoYXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBpc1RyaW0oYnVmLCBwb3MpO1xuICAgIH0sXG4gICAgLy8gS2VlcCBpdCBpbiBjYXNlIHdlIGltcGxlbWVudCB0aGUgYGNhc3RfaW50YCBvcHRpb25cbiAgICAvLyBfX2lzSW50KHZhbHVlKXtcbiAgICAvLyAgIC8vIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlSW50KHZhbHVlKSlcbiAgICAvLyAgIC8vIHJldHVybiAhaXNOYU4oIHBhcnNlSW50KCBvYmogKSApO1xuICAgIC8vICAgcmV0dXJuIC9eKFxcLXxcXCspP1sxLTldWzAtOV0qJC8udGVzdCh2YWx1ZSlcbiAgICAvLyB9XG4gICAgX19pc0Zsb2F0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkgKyAxKSA+PSAwOyAvLyBCb3Jyb3dlZCBmcm9tIGpxdWVyeVxuICAgIH0sXG4gICAgX19jb21wYXJlQnl0ZXM6IGZ1bmN0aW9uKHNvdXJjZUJ1ZiwgdGFyZ2V0QnVmLCB0YXJnZXRQb3MsIGZpcnN0Qnl0ZSl7XG4gICAgICBpZihzb3VyY2VCdWZbMF0gIT09IGZpcnN0Qnl0ZSkgcmV0dXJuIDA7XG4gICAgICBjb25zdCBzb3VyY2VMZW5ndGggPSBzb3VyY2VCdWYubGVuZ3RoO1xuICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHNvdXJjZUxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoc291cmNlQnVmW2ldICE9PSB0YXJnZXRCdWZbdGFyZ2V0UG9zK2ldKSByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2VMZW5ndGg7XG4gICAgfSxcbiAgICBfX2lzRGVsaW1pdGVyOiBmdW5jdGlvbihidWYsIHBvcywgY2hyKXtcbiAgICAgIGNvbnN0IHtkZWxpbWl0ZXIsIGlnbm9yZV9sYXN0X2RlbGltaXRlcnN9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYoaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gdHJ1ZSAmJiB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggPT09IHRoaXMub3B0aW9ucy5jb2x1bW5zLmxlbmd0aCAtIDEpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1lbHNlIGlmKGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgIT09IGZhbHNlICYmIHR5cGVvZiBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSAnbnVtYmVyJyAmJiB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggPT09IGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgLSAxKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBsb29wMTogZm9yKGxldCBpID0gMDsgaSA8IGRlbGltaXRlci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGRlbCA9IGRlbGltaXRlcltpXTtcbiAgICAgICAgaWYoZGVsWzBdID09PSBjaHIpe1xuICAgICAgICAgIGZvcihsZXQgaiA9IDE7IGogPCBkZWwubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYoZGVsW2pdICE9PSBidWZbcG9zK2pdKSBjb250aW51ZSBsb29wMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgX19pc1JlY29yZERlbGltaXRlcjogZnVuY3Rpb24oY2hyLCBidWYsIHBvcyl7XG4gICAgICBjb25zdCB7cmVjb3JkX2RlbGltaXRlcn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCByZWNvcmREZWxpbWl0ZXJMZW5ndGggPSByZWNvcmRfZGVsaW1pdGVyLmxlbmd0aDtcbiAgICAgIGxvb3AxOiBmb3IobGV0IGkgPSAwOyBpIDwgcmVjb3JkRGVsaW1pdGVyTGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCByZCA9IHJlY29yZF9kZWxpbWl0ZXJbaV07XG4gICAgICAgIGNvbnN0IHJkTGVuZ3RoID0gcmQubGVuZ3RoO1xuICAgICAgICBpZihyZFswXSAhPT0gY2hyKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGogPSAxOyBqIDwgcmRMZW5ndGg7IGorKyl7XG4gICAgICAgICAgaWYocmRbal0gIT09IGJ1Zltwb3Mral0pe1xuICAgICAgICAgICAgY29udGludWUgbG9vcDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZC5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIF9faXNFc2NhcGU6IGZ1bmN0aW9uKGJ1ZiwgcG9zLCBjaHIpe1xuICAgICAgY29uc3Qge2VzY2FwZX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZihlc2NhcGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IGwgPSBlc2NhcGUubGVuZ3RoO1xuICAgICAgaWYoZXNjYXBlWzBdID09PSBjaHIpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgICBpZihlc2NhcGVbaV0gIT09IGJ1Zltwb3MraV0pe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9faXNRdW90ZTogZnVuY3Rpb24oYnVmLCBwb3Mpe1xuICAgICAgY29uc3Qge3F1b3RlfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmKHF1b3RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBsID0gcXVvdGUubGVuZ3RoO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGlmKHF1b3RlW2ldICE9PSBidWZbcG9zK2ldKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgX19hdXRvRGlzY292ZXJSZWNvcmREZWxpbWl0ZXI6IGZ1bmN0aW9uKGJ1ZiwgcG9zKXtcbiAgICAgIGNvbnN0IHsgZW5jb2RpbmcgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIC8vIE5vdGUsIHdlIGRvbid0IG5lZWQgdG8gY2FjaGUgdGhpcyBpbmZvcm1hdGlvbiBpbiBzdGF0ZSxcbiAgICAgIC8vIEl0IGlzIG9ubHkgY2FsbGVkIG9uIHRoZSBmaXJzdCBsaW5lIHVudGlsIHdlIGZpbmQgb3V0IGEgc3VpdGFibGVcbiAgICAgIC8vIHJlY29yZCBkZWxpbWl0ZXIuXG4gICAgICBjb25zdCByZHMgPSBbXG4gICAgICAgIC8vIEltcG9ydGFudCwgdGhlIHdpbmRvd3MgbGluZSBlbmRpbmcgbXVzdCBiZSBiZWZvcmUgbWFjIG9zIDlcbiAgICAgICAgQnVmZmVyLmZyb20oJ1xcclxcbicsIGVuY29kaW5nKSxcbiAgICAgICAgQnVmZmVyLmZyb20oJ1xcbicsIGVuY29kaW5nKSxcbiAgICAgICAgQnVmZmVyLmZyb20oJ1xccicsIGVuY29kaW5nKSxcbiAgICAgIF07XG4gICAgICBsb29wOiBmb3IobGV0IGkgPSAwOyBpIDwgcmRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgbCA9IHJkc1tpXS5sZW5ndGg7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBsOyBqKyspe1xuICAgICAgICAgIGlmKHJkc1tpXVtqXSAhPT0gYnVmW3BvcyArIGpdKXtcbiAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyLnB1c2gocmRzW2ldKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGggPSByZHNbaV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmRzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgX19lcnJvcjogZnVuY3Rpb24obXNnKXtcbiAgICAgIGNvbnN0IHtlbmNvZGluZywgcmF3LCBza2lwX3JlY29yZHNfd2l0aF9lcnJvcn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCBlcnIgPSB0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IG5ldyBFcnJvcihtc2cpIDogbXNnO1xuICAgICAgaWYoc2tpcF9yZWNvcmRzX3dpdGhfZXJyb3Ipe1xuICAgICAgICB0aGlzLnN0YXRlLnJlY29yZEhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLm9uX3NraXAgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9uX3NraXAoZXJyLCByYXcgPyB0aGlzLnN0YXRlLnJhd0J1ZmZlci50b1N0cmluZyhlbmNvZGluZykgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuZW1pdCgnc2tpcCcsIGVyciwgcmF3ID8gdGhpcy5zdGF0ZS5yYXdCdWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9faW5mb0RhdGFTZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzLmluZm8sXG4gICAgICAgIGNvbHVtbnM6IHRoaXMub3B0aW9ucy5jb2x1bW5zXG4gICAgICB9O1xuICAgIH0sXG4gICAgX19pbmZvUmVjb3JkOiBmdW5jdGlvbigpe1xuICAgICAgY29uc3Qge2NvbHVtbnMsIHJhdywgZW5jb2Rpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy5fX2luZm9EYXRhU2V0KCksXG4gICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICBoZWFkZXI6IGNvbHVtbnMgPT09IHRydWUsXG4gICAgICAgIGluZGV4OiB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGgsXG4gICAgICAgIHJhdzogcmF3ID8gdGhpcy5zdGF0ZS5yYXdCdWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgX19pbmZvRmllbGQ6IGZ1bmN0aW9uKCl7XG4gICAgICBjb25zdCB7Y29sdW1uc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCBpc0NvbHVtbnMgPSBBcnJheS5pc0FycmF5KGNvbHVtbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy5fX2luZm9SZWNvcmQoKSxcbiAgICAgICAgY29sdW1uOiBpc0NvbHVtbnMgPT09IHRydWUgP1xuICAgICAgICAgIChjb2x1bW5zLmxlbmd0aCA+IHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA/XG4gICAgICAgICAgICBjb2x1bW5zW3RoaXMuc3RhdGUucmVjb3JkLmxlbmd0aF0ubmFtZSA6XG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKSA6XG4gICAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoLFxuICAgICAgICBxdW90aW5nOiB0aGlzLnN0YXRlLndhc1F1b3RpbmcsXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbmNsYXNzIFBhcnNlciBleHRlbmRzIHN0cmVhbS5UcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pe1xuICAgIHN1cGVyKHsuLi57cmVhZGFibGVPYmplY3RNb2RlOiB0cnVlfSwgLi4ub3B0cywgZW5jb2Rpbmc6IG51bGx9KTtcbiAgICB0aGlzLmFwaSA9IHRyYW5zZm9ybSQxKG9wdHMpO1xuICAgIHRoaXMuYXBpLm9wdGlvbnMub25fc2tpcCA9IChlcnIsIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ3NraXAnLCBlcnIsIGNodW5rKTtcbiAgICB9O1xuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5hcGkuc3RhdGU7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5hcGkub3B0aW9ucztcbiAgICB0aGlzLmluZm8gPSB0aGlzLmFwaS5pbmZvO1xuICB9XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGBUcmFuc2Zvcm0uX3RyYW5zZm9ybWBcbiAgX3RyYW5zZm9ybShidWYsIGVuY29kaW5nLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zdGF0ZS5zdG9wID09PSB0cnVlKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXJyID0gdGhpcy5hcGkucGFyc2UoYnVmLCBmYWxzZSwgKHJlY29yZCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKHJlY29yZCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgdGhpcy5vbignZW5kJywgdGhpcy5kZXN0cm95KTtcbiAgICB9KTtcbiAgICBpZihlcnIgIT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLnN0YXRlLnN0b3AgPSB0cnVlO1xuICAgIH1cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGBUcmFuc2Zvcm0uX2ZsdXNoYFxuICBfZmx1c2goY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuc3RhdGUuc3RvcCA9PT0gdHJ1ZSl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVyciA9IHRoaXMuYXBpLnBhcnNlKHVuZGVmaW5lZCwgdHJ1ZSwgKHJlY29yZCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKHJlY29yZCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgdGhpcy5vbignZW5kJywgdGhpcy5kZXN0cm95KTtcbiAgICB9KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG59XG5cbmNvbnN0IHBhcnNlID0gZnVuY3Rpb24oKXtcbiAgbGV0IGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrO1xuICBmb3IoY29uc3QgaSBpbiBhcmd1bWVudHMpe1xuICAgIGNvbnN0IGFyZ3VtZW50ID0gYXJndW1lbnRzW2ldO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJndW1lbnQ7XG4gICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkICYmICh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihhcmd1bWVudCkpKXtcbiAgICAgIGRhdGEgPSBhcmd1bWVudDtcbiAgICB9ZWxzZSBpZihvcHRpb25zID09PSB1bmRlZmluZWQgJiYgaXNfb2JqZWN0JDEoYXJndW1lbnQpKXtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudDtcbiAgICB9ZWxzZSBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGUgPT09ICdmdW5jdGlvbicpe1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudDtcbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IkMSgnQ1NWX0lOVkFMSURfQVJHVU1FTlQnLCBbXG4gICAgICAgICdJbnZhbGlkIGFyZ3VtZW50OicsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShhcmd1bWVudCl9IGF0IGluZGV4ICR7aX1gXG4gICAgICBdLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgaWYoY2FsbGJhY2spe1xuICAgIGNvbnN0IHJlY29yZHMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vYmpuYW1lID09PSB1bmRlZmluZWQgPyBbXSA6IHt9O1xuICAgIHBhcnNlci5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpe1xuICAgICAgbGV0IHJlY29yZDtcbiAgICAgIHdoaWxlKChyZWNvcmQgPSB0aGlzLnJlYWQoKSkgIT09IG51bGwpe1xuICAgICAgICBpZihvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vYmpuYW1lID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgcmVjb3Jkc1tyZWNvcmRbMF1dID0gcmVjb3JkWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGFyc2VyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgICBjYWxsYmFjayhlcnIsIHVuZGVmaW5lZCwgcGFyc2VyLmFwaS5fX2luZm9EYXRhU2V0KCkpO1xuICAgIH0pO1xuICAgIHBhcnNlci5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVjb3JkcywgcGFyc2VyLmFwaS5fX2luZm9EYXRhU2V0KCkpO1xuICAgIH0pO1xuICB9XG4gIGlmKGRhdGEgIT09IHVuZGVmaW5lZCl7XG4gICAgY29uc3Qgd3JpdGVyID0gZnVuY3Rpb24oKXtcbiAgICAgIHBhcnNlci53cml0ZShkYXRhKTtcbiAgICAgIHBhcnNlci5lbmQoKTtcbiAgICB9O1xuICAgIC8vIFN1cHBvcnQgRGVubywgUm9sbHVwIGRvZXNudCBwcm92aWRlIGEgc2hpbSBmb3Igc2V0SW1tZWRpYXRlXG4gICAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBzZXRJbW1lZGlhdGUod3JpdGVyKTtcbiAgICB9ZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHdyaXRlciwgMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZXI7XG59O1xuXG5jb25zdCBUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKG9wdGlvbnMgPSB7fSwgaGFuZGxlcil7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmKG9wdGlvbnMuY29uc3VtZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY29uc3VtZSA9PT0gbnVsbCl7XG4gICAgdGhpcy5vcHRpb25zLmNvbnN1bWUgPSBmYWxzZTtcbiAgfVxuICB0aGlzLm9wdGlvbnMub2JqZWN0TW9kZSA9IHRydWU7XG4gIGlmKG9wdGlvbnMucGFyYWxsZWwgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBhcmFsbGVsID09PSBudWxsKXtcbiAgICB0aGlzLm9wdGlvbnMucGFyYWxsZWwgPSAxMDA7XG4gIH1cbiAgaWYob3B0aW9ucy5wYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBhcmFtcyA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5wYXJhbXMgPSBudWxsO1xuICB9XG4gIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gIHN0cmVhbS5UcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICB0aGlzLnN0YXRlID0ge1xuICAgIHJ1bm5pbmc6IDAsXG4gICAgc3RhcnRlZDogMCxcbiAgICBmaW5pc2hlZDogMFxuICB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtZXIsIHN0cmVhbS5UcmFuc2Zvcm0pO1xuXG5UcmFuc2Zvcm1lci5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2Ipe1xuICB0aGlzLnN0YXRlLnN0YXJ0ZWQrKztcbiAgdGhpcy5zdGF0ZS5ydW5uaW5nKys7XG4gIGlmKHRoaXMuc3RhdGUucnVubmluZyA8IHRoaXMub3B0aW9ucy5wYXJhbGxlbCl7XG4gICAgY2IoKTtcbiAgICBjYiA9IG51bGw7IC8vIENhbmNlbCBmdXJ0aGVyIGNhbGxiYWNrIGV4ZWN1dGlvblxuICB9XG4gIHRyeSB7XG4gICAgbGV0IGwgPSB0aGlzLmhhbmRsZXIubGVuZ3RoO1xuICAgIGlmKHRoaXMub3B0aW9ucy5wYXJhbXMgIT09IG51bGwpeyAgXG4gICAgICBsLS07XG4gICAgfVxuICAgIGlmKGwgPT09IDEpeyAvLyBzeW5jXG4gICAgICB0aGlzLl9fZG9uZShudWxsLCBbdGhpcy5oYW5kbGVyLmNhbGwodGhpcywgY2h1bmssIHRoaXMub3B0aW9ucy5wYXJhbXMpXSwgY2IpO1xuICAgIH1lbHNlIGlmKGwgPT09IDIpeyAvLyBhc3luY1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyLCAuLi5jaHVua3MpID0+XG4gICAgICAgIHRoaXMuX19kb25lKGVyciwgY2h1bmtzLCBjYik7XG4gICAgICB0aGlzLmhhbmRsZXIuY2FsbCh0aGlzLCBjaHVuaywgY2FsbGJhY2ssIHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgIH1lbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGhhbmRsZXIgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5fX2RvbmUoZXJyKTtcbiAgfVxufTtcblRyYW5zZm9ybWVyLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYil7XG4gIGlmKHRoaXMuc3RhdGUucnVubmluZyA9PT0gMCl7XG4gICAgY2IoKTtcbiAgfWVsc2Uge1xuICAgIHRoaXMuX2VuZGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICBjYigpO1xuICAgIH07XG4gIH1cbn07XG5UcmFuc2Zvcm1lci5wcm90b3R5cGUuX19kb25lID0gZnVuY3Rpb24oZXJyLCBjaHVua3MsIGNiKXtcbiAgdGhpcy5zdGF0ZS5ydW5uaW5nLS07XG4gIGlmKGVycil7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG4gIHRoaXMuc3RhdGUuZmluaXNoZWQrKztcbiAgZm9yKGxldCBjaHVuayBvZiBjaHVua3Mpe1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdudW1iZXInKXtcbiAgICAgIGNodW5rID0gYCR7Y2h1bmt9YDtcbiAgICB9XG4gICAgLy8gV2UgZG9udCBwdXNoIGVtcHR5IHN0cmluZ1xuICAgIC8vIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9yZWFkYWJsZV9wdXNoXG4gICAgaWYoY2h1bmsgIT09IHVuZGVmaW5lZCAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gJycpe1xuICAgICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gIH1cbiAgaWYoY2Ipe1xuICAgIGNiKCk7XG4gIH1cbiAgaWYodGhpcy5fZW5kaW5nICYmIHRoaXMuc3RhdGUucnVubmluZyA9PT0gMCl7XG4gICAgdGhpcy5fZW5kaW5nKCk7XG4gIH1cbn07XG5jb25zdCB0cmFuc2Zvcm0gPSBmdW5jdGlvbigpe1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBsZXQgY2FsbGJhY2ssIGhhbmRsZXIsIHJlY29yZHM7XG4gIGZvcihsZXQgaSA9IDA7IGk8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgY29uc3QgYXJndW1lbnQgPSBhcmd1bWVudHNbaV07XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgYXJndW1lbnQ7XG4gICAgaWYoYXJndW1lbnQgPT09IG51bGwpe1xuICAgICAgdHlwZSA9ICdudWxsJztcbiAgICB9ZWxzZSBpZih0eXBlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50KSl7XG4gICAgICB0eXBlID0gJ2FycmF5JztcbiAgICB9XG4gICAgaWYodHlwZSA9PT0gJ2FycmF5Jyl7XG4gICAgICByZWNvcmRzID0gYXJndW1lbnQ7XG4gICAgfWVsc2UgaWYodHlwZSA9PT0gJ29iamVjdCcpe1xuICAgICAgb3B0aW9ucyA9IHsuLi5hcmd1bWVudH07XG4gICAgfWVsc2UgaWYodHlwZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBpZiAoaGFuZGxlciAmJiBpID09PSBhcmd1bWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlciA9IGFyZ3VtZW50O1xuICAgICAgfVxuICAgIH1lbHNlIGlmKHR5cGUgIT09ICdudWxsJyl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQXJndW1lbnRzOiBnb3QgJHtKU09OLnN0cmluZ2lmeShhcmd1bWVudCl9IGF0IHBvc2l0aW9uICR7aX1gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXIob3B0aW9ucywgaGFuZGxlcik7XG4gIGxldCBlcnJvciA9IGZhbHNlO1xuICBpZiAocmVjb3Jkcykge1xuICAgIGNvbnN0IHdyaXRlciA9IGZ1bmN0aW9uKCl7XG4gICAgICBmb3IoY29uc3QgcmVjb3JkIG9mIHJlY29yZHMpe1xuICAgICAgICBpZihlcnJvcikgYnJlYWs7XG4gICAgICAgIHRyYW5zZm9ybWVyLndyaXRlKHJlY29yZCk7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm1lci5lbmQoKTtcbiAgICB9O1xuICAgIC8vIFN1cHBvcnQgRGVubywgUm9sbHVwIGRvZXNudCBwcm92aWRlIGEgc2hpbSBmb3Igc2V0SW1tZWRpYXRlXG4gICAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBzZXRJbW1lZGlhdGUod3JpdGVyKTtcbiAgICB9ZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHdyaXRlciwgMCk7XG4gICAgfVxuICB9XG4gIGlmKGNhbGxiYWNrIHx8IG9wdGlvbnMuY29uc3VtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHRyYW5zZm9ybWVyLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCl7XG4gICAgICBsZXQgcmVjb3JkOyB3aGlsZSgocmVjb3JkID0gdHJhbnNmb3JtZXIucmVhZCgpKSAhPT0gbnVsbCl7XG4gICAgICAgIGlmKGNhbGxiYWNrKXtcbiAgICAgICAgICByZXN1bHQucHVzaChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJhbnNmb3JtZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICB0cmFuc2Zvcm1lci5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgIGlmIChjYWxsYmFjayAmJiAhZXJyb3IpIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybWVyO1xufTtcblxuY2xhc3MgQ3N2RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIC4uLmNvbnRleHRzKSB7XG4gICAgaWYoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkgbWVzc2FnZSA9IG1lc3NhZ2Uuam9pbignICcpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSB1bmRlZmluZWQpe1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3N2RXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGZvcihjb25zdCBjb250ZXh0IG9mIGNvbnRleHRzKXtcbiAgICAgIGZvcihjb25zdCBrZXkgaW4gY29udGV4dCl7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dFtrZXldO1xuICAgICAgICB0aGlzW2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNfb2JqZWN0ID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiAhIEFycmF5LmlzQXJyYXkob2JqKTtcbn07XG5cbi8vIExvZGFzaCBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0YFxuXG5jb25zdCBjaGFyQ29kZU9mRG90ID0gJy4nLmNoYXJDb2RlQXQoMCk7XG5jb25zdCByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcbmNvbnN0IHJlUHJvcE5hbWUgPSBSZWdFeHAoXG4gIC8vIE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBkb3Qgb3IgYnJhY2tldC5cbiAgJ1teLltcXFxcXV0rJyArICd8JyArXG4gIC8vIE9yIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBicmFja2V0cy5cbiAgJ1xcXFxbKD86JyArXG4gICAgLy8gTWF0Y2ggYSBub24tc3RyaW5nIGV4cHJlc3Npb24uXG4gICAgJyhbXlwiXFwnXVteW10qKScgKyAnfCcgK1xuICAgIC8vIE9yIG1hdGNoIHN0cmluZ3MgKHN1cHBvcnRzIGVzY2FwaW5nIGNoYXJhY3RlcnMpLlxuICAgICcoW1wiXFwnXSkoKD86KD8hXFxcXDIpW15cXFxcXFxcXF18XFxcXFxcXFwuKSo/KVxcXFwyJyArXG4gICcpXFxcXF0nKyAnfCcgK1xuICAvLyBPciBtYXRjaCBcIlwiIGFzIHRoZSBzcGFjZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGRvdHMgb3IgZW1wdHkgYnJhY2tldHMuXG4gICcoPz0oPzpcXFxcLnxcXFxcW1xcXFxdKSg/OlxcXFwufFxcXFxbXFxcXF18JCkpJ1xuICAsICdnJyk7XG5jb25zdCByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vO1xuY29uc3QgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuY29uc3QgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbn07XG5jb25zdCBpc1N5bWJvbCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT09ICdzeW1ib2wnIHx8ICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiBnZXRUYWcodmFsdWUpID09PSAnW29iamVjdCBTeW1ib2xdJyk7XG59O1xuY29uc3QgaXNLZXkgPSBmdW5jdGlvbih2YWx1ZSwgb2JqZWN0KXtcbiAgaWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZih0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnc3ltYm9sJyB8fCB0eXBlID09PSAnYm9vbGVhbicgfHwgIXZhbHVlIHx8IGlzU3ltYm9sKHZhbHVlKSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59O1xuY29uc3Qgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24oc3RyaW5nKXtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSBjaGFyQ29kZU9mRG90KXtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIGV4cHJlc3Npb24sIHF1b3RlLCBzdWJTdHJpbmcpe1xuICAgIGxldCBrZXkgPSBtYXRjaDtcbiAgICBpZihxdW90ZSl7XG4gICAgICBrZXkgPSBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpO1xuICAgIH1lbHNlIGlmKGV4cHJlc3Npb24pe1xuICAgICAga2V5ID0gZXhwcmVzc2lvbi50cmltKCk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGNhc3RQYXRoID0gZnVuY3Rpb24odmFsdWUsIG9iamVjdCl7XG4gIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKXtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG4gIH1cbn07XG5jb25zdCB0b0tleSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgaWYodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCByZXN1bHQgPSBgJHt2YWx1ZX1gO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufTtcbmNvbnN0IGdldCA9IGZ1bmN0aW9uKG9iamVjdCwgcGF0aCl7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgd2hpbGUob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpe1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9jb2x1bW5zID0gZnVuY3Rpb24oY29sdW1ucyl7XG4gIGlmKGNvbHVtbnMgPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5zID09PSBudWxsKXtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbiAgfVxuICBpZih0eXBlb2YgY29sdW1ucyAhPT0gJ29iamVjdCcpe1xuICAgIHJldHVybiBbRXJyb3IoJ0ludmFsaWQgb3B0aW9uIFwiY29sdW1uc1wiOiBleHBlY3QgYW4gYXJyYXkgb3IgYW4gb2JqZWN0JyldO1xuICB9XG4gIGlmKCFBcnJheS5pc0FycmF5KGNvbHVtbnMpKXtcbiAgICBjb25zdCBuZXdjb2x1bW5zID0gW107XG4gICAgZm9yKGNvbnN0IGsgaW4gY29sdW1ucyl7XG4gICAgICBuZXdjb2x1bW5zLnB1c2goe1xuICAgICAgICBrZXk6IGssXG4gICAgICAgIGhlYWRlcjogY29sdW1uc1trXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbHVtbnMgPSBuZXdjb2x1bW5zO1xuICB9ZWxzZSB7XG4gICAgY29uc3QgbmV3Y29sdW1ucyA9IFtdO1xuICAgIGZvcihjb25zdCBjb2x1bW4gb2YgY29sdW1ucyl7XG4gICAgICBpZih0eXBlb2YgY29sdW1uID09PSAnc3RyaW5nJyl7XG4gICAgICAgIG5ld2NvbHVtbnMucHVzaCh7XG4gICAgICAgICAga2V5OiBjb2x1bW4sXG4gICAgICAgICAgaGVhZGVyOiBjb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICB9ZWxzZSBpZih0eXBlb2YgY29sdW1uID09PSAnb2JqZWN0JyAmJiBjb2x1bW4gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoY29sdW1uKSl7XG4gICAgICAgIGlmKCFjb2x1bW4ua2V5KXtcbiAgICAgICAgICByZXR1cm4gW0Vycm9yKCdJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiBwcm9wZXJ0eSBcImtleVwiIGlzIHJlcXVpcmVkJyldO1xuICAgICAgICB9XG4gICAgICAgIGlmKGNvbHVtbi5oZWFkZXIgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgY29sdW1uLmhlYWRlciA9IGNvbHVtbi5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Y29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHJldHVybiBbRXJyb3IoJ0ludmFsaWQgY29sdW1uIGRlZmluaXRpb246IGV4cGVjdCBhIHN0cmluZyBvciBhbiBvYmplY3QnKV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbHVtbnMgPSBuZXdjb2x1bW5zO1xuICB9XG4gIHJldHVybiBbdW5kZWZpbmVkLCBjb2x1bW5zXTtcbn07XG5cbmNvbnN0IHVuZGVyc2NvcmUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24oXywgbWF0Y2gpe1xuICAgIHJldHVybiAnXycgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9vcHRpb25zID0gZnVuY3Rpb24ob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge307XG4gIC8vIE1lcmdlIHdpdGggdXNlciBvcHRpb25zXG4gIGZvcihjb25zdCBvcHQgaW4gb3B0cyl7XG4gICAgb3B0aW9uc1t1bmRlcnNjb3JlKG9wdCldID0gb3B0c1tvcHRdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGJvbWBcbiAgaWYob3B0aW9ucy5ib20gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmJvbSA9PT0gbnVsbCB8fCBvcHRpb25zLmJvbSA9PT0gZmFsc2Upe1xuICAgIG9wdGlvbnMuYm9tID0gZmFsc2U7XG4gIH1lbHNlIGlmKG9wdGlvbnMuYm9tICE9PSB0cnVlKXtcbiAgICByZXR1cm4gW25ldyBDc3ZFcnJvcignQ1NWX09QVElPTl9CT09MRUFOX0lOVkFMSURfVFlQRScsIFtcbiAgICAgICdvcHRpb24gYGJvbWAgaXMgb3B0aW9uYWwgYW5kIG11c3QgYmUgYSBib29sZWFuIHZhbHVlLCcsXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib20pfWBcbiAgICBdKV07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZGVsaW1pdGVyYFxuICBpZihvcHRpb25zLmRlbGltaXRlciA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZGVsaW1pdGVyID09PSBudWxsKXtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9ICcsJztcbiAgfWVsc2UgaWYoQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuZGVsaW1pdGVyKSl7XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlci50b1N0cmluZygpO1xuICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgIT09ICdzdHJpbmcnKXtcbiAgICByZXR1cm4gW25ldyBDc3ZFcnJvcignQ1NWX09QVElPTl9ERUxJTUlURVJfSU5WQUxJRF9UWVBFJywgW1xuICAgICAgJ29wdGlvbiBgZGVsaW1pdGVyYCBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCcsXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5kZWxpbWl0ZXIpfWBcbiAgICBdKV07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVgXG4gIGlmKG9wdGlvbnMucXVvdGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnF1b3RlID09PSBudWxsKXtcbiAgICBvcHRpb25zLnF1b3RlID0gJ1wiJztcbiAgfWVsc2UgaWYob3B0aW9ucy5xdW90ZSA9PT0gdHJ1ZSl7XG4gICAgb3B0aW9ucy5xdW90ZSA9ICdcIic7XG4gIH1lbHNlIGlmKG9wdGlvbnMucXVvdGUgPT09IGZhbHNlKXtcbiAgICBvcHRpb25zLnF1b3RlID0gJyc7XG4gIH1lbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5xdW90ZSkpe1xuICAgIG9wdGlvbnMucXVvdGUgPSBvcHRpb25zLnF1b3RlLnRvU3RyaW5nKCk7XG4gIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLnF1b3RlICE9PSAnc3RyaW5nJyl7XG4gICAgcmV0dXJuIFtuZXcgQ3N2RXJyb3IoJ0NTVl9PUFRJT05fUVVPVEVfSU5WQUxJRF9UWVBFJywgW1xuICAgICAgJ29wdGlvbiBgcXVvdGVgIG11c3QgYmUgYSBib29sZWFuLCBhIGJ1ZmZlciBvciBhIHN0cmluZywnLFxuICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucXVvdGUpfWBcbiAgICBdKV07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkYFxuICBpZihvcHRpb25zLnF1b3RlZCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkID09PSBudWxsKXtcbiAgICBvcHRpb25zLnF1b3RlZCA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGVzY2FwZV9mb3JtdWxhc2BcbiAgaWYob3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPSBmYWxzZTtcbiAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMuZXNjYXBlX2Zvcm11bGFzICE9PSAnYm9vbGVhbicpe1xuICAgIHJldHVybiBbbmV3IENzdkVycm9yKCdDU1ZfT1BUSU9OX0VTQ0FQRV9GT1JNVUxBU19JTlZBTElEX1RZUEUnLCBbXG4gICAgICAnb3B0aW9uIGBlc2NhcGVfZm9ybXVsYXNgIG11c3QgYmUgYSBib29sZWFuLCcsXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMpfWBcbiAgICBdKV07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkX2VtcHR5YFxuICBpZihvcHRpb25zLnF1b3RlZF9lbXB0eSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkX2VtcHR5ID09PSBudWxsKXtcbiAgICBvcHRpb25zLnF1b3RlZF9lbXB0eSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRfbWF0Y2hgXG4gIGlmKG9wdGlvbnMucXVvdGVkX21hdGNoID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPT09IG51bGwgfHwgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPT09IGZhbHNlKXtcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9IG51bGw7XG4gIH1lbHNlIGlmKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucXVvdGVkX21hdGNoKSl7XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPSBbb3B0aW9ucy5xdW90ZWRfbWF0Y2hdO1xuICB9XG4gIGlmKG9wdGlvbnMucXVvdGVkX21hdGNoKXtcbiAgICBmb3IoY29uc3QgcXVvdGVkX21hdGNoIG9mIG9wdGlvbnMucXVvdGVkX21hdGNoKXtcbiAgICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIHF1b3RlZF9tYXRjaCA9PT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBpc1JlZ0V4cCA9IHF1b3RlZF9tYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgIGlmKCFpc1N0cmluZyAmJiAhaXNSZWdFeHApe1xuICAgICAgICByZXR1cm4gW0Vycm9yKGBJbnZhbGlkIE9wdGlvbjogcXVvdGVkX21hdGNoIG11c3QgYmUgYSBzdHJpbmcgb3IgYSByZWdleCwgZ290ICR7SlNPTi5zdHJpbmdpZnkocXVvdGVkX21hdGNoKX1gKV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZF9zdHJpbmdgXG4gIGlmKG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5xdW90ZWRfc3RyaW5nID0gZmFsc2U7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZW9mYFxuICBpZihvcHRpb25zLmVvZiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZW9mID09PSBudWxsKXtcbiAgICBvcHRpb25zLmVvZiA9IHRydWU7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZXNjYXBlYFxuICBpZihvcHRpb25zLmVzY2FwZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZXNjYXBlID09PSBudWxsKXtcbiAgICBvcHRpb25zLmVzY2FwZSA9ICdcIic7XG4gIH1lbHNlIGlmKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmVzY2FwZSkpe1xuICAgIG9wdGlvbnMuZXNjYXBlID0gb3B0aW9ucy5lc2NhcGUudG9TdHJpbmcoKTtcbiAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMuZXNjYXBlICE9PSAnc3RyaW5nJyl7XG4gICAgcmV0dXJuIFtFcnJvcihgSW52YWxpZCBPcHRpb246IGVzY2FwZSBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVzY2FwZSl9YCldO1xuICB9XG4gIGlmIChvcHRpb25zLmVzY2FwZS5sZW5ndGggPiAxKXtcbiAgICByZXR1cm4gW0Vycm9yKGBJbnZhbGlkIE9wdGlvbjogZXNjYXBlIG11c3QgYmUgb25lIGNoYXJhY3RlciwgZ290ICR7b3B0aW9ucy5lc2NhcGUubGVuZ3RofSBjaGFyYWN0ZXJzYCldO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGhlYWRlcmBcbiAgaWYob3B0aW9ucy5oZWFkZXIgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlYWRlciA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5oZWFkZXIgPSBmYWxzZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjb2x1bW5zYFxuICBjb25zdCBbZXJyQ29sdW1ucywgY29sdW1uc10gPSBub3JtYWxpemVfY29sdW1ucyhvcHRpb25zLmNvbHVtbnMpO1xuICBpZihlcnJDb2x1bW5zICE9PSB1bmRlZmluZWQpIHJldHVybiBbZXJyQ29sdW1uc107XG4gIG9wdGlvbnMuY29sdW1ucyA9IGNvbHVtbnM7XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZGBcbiAgaWYob3B0aW9ucy5xdW90ZWQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnF1b3RlZCA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5xdW90ZWQgPSBmYWxzZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjYXN0YFxuICBpZihvcHRpb25zLmNhc3QgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QgPT09IG51bGwpe1xuICAgIG9wdGlvbnMuY2FzdCA9IHt9O1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5iaWdpbnRcbiAgaWYob3B0aW9ucy5jYXN0LmJpZ2ludCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5iaWdpbnQgPT09IG51bGwpe1xuICAgIC8vIENhc3QgYm9vbGVhbiB0byBzdHJpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5iaWdpbnQgPSB2YWx1ZSA9PiAnJyArIHZhbHVlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5ib29sZWFuXG4gIGlmKG9wdGlvbnMuY2FzdC5ib29sZWFuID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0LmJvb2xlYW4gPT09IG51bGwpe1xuICAgIC8vIENhc3QgYm9vbGVhbiB0byBzdHJpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5ib29sZWFuID0gdmFsdWUgPT4gdmFsdWUgPyAnMScgOiAnJztcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3QuZGF0ZVxuICBpZihvcHRpb25zLmNhc3QuZGF0ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5kYXRlID09PSBudWxsKXtcbiAgICAvLyBDYXN0IGRhdGUgdG8gdGltZXN0YW1wIHN0cmluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0LmRhdGUgPSB2YWx1ZSA9PiAnJyArIHZhbHVlLmdldFRpbWUoKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3QubnVtYmVyXG4gIGlmKG9wdGlvbnMuY2FzdC5udW1iZXIgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QubnVtYmVyID09PSBudWxsKXtcbiAgICAvLyBDYXN0IG51bWJlciB0byBzdHJpbmcgdXNpbmcgbmF0aXZlIGNhc3RpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5udW1iZXIgPSB2YWx1ZSA9PiAnJyArIHZhbHVlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5vYmplY3RcbiAgaWYob3B0aW9ucy5jYXN0Lm9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5vYmplY3QgPT09IG51bGwpe1xuICAgIC8vIFN0cmluZ2lmeSBvYmplY3QgYXMgSlNPTiBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0Lm9iamVjdCA9IHZhbHVlID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3Quc3RyaW5nXG4gIGlmKG9wdGlvbnMuY2FzdC5zdHJpbmcgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3Quc3RyaW5nID09PSBudWxsKXtcbiAgICAvLyBMZWF2ZSBzdHJpbmcgdW50b3VjaGVkXG4gICAgb3B0aW9ucy5jYXN0LnN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gdmFsdWU7fTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBvbl9yZWNvcmRgXG4gIGlmKG9wdGlvbnMub25fcmVjb3JkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMub25fcmVjb3JkICE9PSAnZnVuY3Rpb24nKXtcbiAgICByZXR1cm4gW0Vycm9yKGBJbnZhbGlkIE9wdGlvbjogXCJvbl9yZWNvcmRcIiBtdXN0IGJlIGEgZnVuY3Rpb24uYCldO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJlY29yZF9kZWxpbWl0ZXJgXG4gIGlmKG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9PT0gbnVsbCl7XG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gJ1xcbic7XG4gIH1lbHNlIGlmKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpKXtcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIudG9TdHJpbmcoKTtcbiAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciAhPT0gJ3N0cmluZycpe1xuICAgIHJldHVybiBbRXJyb3IoYEludmFsaWQgT3B0aW9uOiByZWNvcmRfZGVsaW1pdGVyIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucmVjb3JkX2RlbGltaXRlcil9YCldO1xuICB9XG4gIHN3aXRjaChvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpe1xuICBjYXNlICdhdXRvJzpcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBudWxsO1xuICAgIGJyZWFrO1xuICBjYXNlICd1bml4JzpcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBcIlxcblwiO1xuICAgIGJyZWFrO1xuICBjYXNlICdtYWMnOlxuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxyXCI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3dpbmRvd3MnOlxuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxyXFxuXCI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FzY2lpJzpcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBcIlxcdTAwMWVcIjtcbiAgICBicmVhaztcbiAgY2FzZSAndW5pY29kZSc6XG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHUyMDI4XCI7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIFt1bmRlZmluZWQsIG9wdGlvbnNdO1xufTtcblxuY29uc3QgYm9tX3V0ZjggPSBCdWZmZXIuZnJvbShbMjM5LCAxODcsIDE5MV0pO1xuXG5jb25zdCBzdHJpbmdpZmllciA9IGZ1bmN0aW9uKG9wdGlvbnMsIHN0YXRlLCBpbmZvKXtcbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBpbmZvOiBpbmZvLFxuICAgIF9fdHJhbnNmb3JtOiBmdW5jdGlvbihjaHVuaywgcHVzaCl7XG4gICAgICAvLyBDaHVuayB2YWxpZGF0aW9uXG4gICAgICBpZighQXJyYXkuaXNBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnb2JqZWN0Jyl7XG4gICAgICAgIHJldHVybiBFcnJvcihgSW52YWxpZCBSZWNvcmQ6IGV4cGVjdCBhbiBhcnJheSBvciBhbiBvYmplY3QsIGdvdCAke0pTT04uc3RyaW5naWZ5KGNodW5rKX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBjb2x1bW5zIGZyb20gdGhlIGZpcnN0IHJlY29yZFxuICAgICAgaWYodGhpcy5pbmZvLnJlY29yZHMgPT09IDApe1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KGNodW5rKSl7XG4gICAgICAgICAgaWYodGhpcy5vcHRpb25zLmhlYWRlciA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuY29sdW1ucyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcignVW5kaXNjb3ZlcmFibGUgQ29sdW1uczogaGVhZGVyIG9wdGlvbiByZXF1aXJlcyBjb2x1bW4gb3B0aW9uIG9yIG9iamVjdCByZWNvcmRzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSBpZih0aGlzLm9wdGlvbnMuY29sdW1ucyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICBjb25zdCBbZXJyLCBjb2x1bW5zXSA9IG5vcm1hbGl6ZV9jb2x1bW5zKE9iamVjdC5rZXlzKGNodW5rKSk7XG4gICAgICAgICAgaWYoZXJyKSByZXR1cm47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFbWl0IHRoZSBoZWFkZXJcbiAgICAgIGlmKHRoaXMuaW5mby5yZWNvcmRzID09PSAwKXtcbiAgICAgICAgdGhpcy5ib20ocHVzaCk7XG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuaGVhZGVycyhwdXNoKTtcbiAgICAgICAgaWYoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgLy8gRW1pdCBhbmQgc3RyaW5naWZ5IHRoZSByZWNvcmQgaWYgYW4gb2JqZWN0IG9yIGFuIGFycmF5XG4gICAgICB0cnl7XG4gICAgICAgIC8vIHRoaXMuZW1pdCgncmVjb3JkJywgY2h1bmssIHRoaXMuaW5mby5yZWNvcmRzKTtcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLm9uX3JlY29yZCl7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9uX3JlY29yZChjaHVuaywgdGhpcy5pbmZvLnJlY29yZHMpO1xuICAgICAgICB9XG4gICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIC8vIENvbnZlcnQgdGhlIHJlY29yZCBpbnRvIGEgc3RyaW5nXG4gICAgICBsZXQgZXJyLCBjaHVua19zdHJpbmc7XG4gICAgICBpZih0aGlzLm9wdGlvbnMuZW9mKXtcbiAgICAgICAgW2VyciwgY2h1bmtfc3RyaW5nXSA9IHRoaXMuc3RyaW5naWZ5KGNodW5rKTtcbiAgICAgICAgaWYoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgICBpZihjaHVua19zdHJpbmcgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgY2h1bmtfc3RyaW5nID0gY2h1bmtfc3RyaW5nICsgdGhpcy5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgW2VyciwgY2h1bmtfc3RyaW5nXSA9IHRoaXMuc3RyaW5naWZ5KGNodW5rKTtcbiAgICAgICAgaWYoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgICBpZihjaHVua19zdHJpbmcgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgaWYodGhpcy5vcHRpb25zLmhlYWRlciB8fCB0aGlzLmluZm8ucmVjb3Jkcyl7XG4gICAgICAgICAgICBjaHVua19zdHJpbmcgPSB0aGlzLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlciArIGNodW5rX3N0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVtaXQgdGhlIGNzdlxuICAgICAgdGhpcy5pbmZvLnJlY29yZHMrKztcbiAgICAgIHB1c2goY2h1bmtfc3RyaW5nKTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24oY2h1bmssIGNodW5rSXNIZWFkZXI9ZmFsc2Upe1xuICAgICAgaWYodHlwZW9mIGNodW5rICE9PSAnb2JqZWN0Jyl7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBjaHVua107XG4gICAgICB9XG4gICAgICBjb25zdCB7Y29sdW1uc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCByZWNvcmQgPSBbXTtcbiAgICAgIC8vIFJlY29yZCBpcyBhbiBhcnJheVxuICAgICAgaWYoQXJyYXkuaXNBcnJheShjaHVuaykpe1xuICAgICAgICAvLyBXZSBhcmUgZ2V0dGluZyBhbiBhcnJheSBidXQgdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBvdXRwdXQgY29sdW1ucy4gSW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLCB3ZSByZXNwZWN0IHRoZSBjb2x1bW5zIGluZGV4ZXNcbiAgICAgICAgaWYoY29sdW1ucyl7XG4gICAgICAgICAgY2h1bmsuc3BsaWNlKGNvbHVtbnMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXN0IHJlY29yZCBlbGVtZW50c1xuICAgICAgICBmb3IobGV0IGk9MDsgaTxjaHVuay5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgY29uc3QgZmllbGQgPSBjaHVua1tpXTtcbiAgICAgICAgICBjb25zdCBbZXJyLCB2YWx1ZV0gPSB0aGlzLl9fY2FzdChmaWVsZCwge1xuICAgICAgICAgICAgaW5kZXg6IGksIGNvbHVtbjogaSwgcmVjb3JkczogdGhpcy5pbmZvLnJlY29yZHMsIGhlYWRlcjogY2h1bmtJc0hlYWRlclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKGVycikgcmV0dXJuIFtlcnJdO1xuICAgICAgICAgIHJlY29yZFtpXSA9IFt2YWx1ZSwgZmllbGRdO1xuICAgICAgICB9XG4gICAgICAvLyBSZWNvcmQgaXMgYSBsaXRlcmFsIG9iamVjdFxuICAgICAgLy8gYGNvbHVtbnNgIGlzIGFsd2F5cyBkZWZpbmVkOiBpdCBpcyBlaXRoZXIgcHJvdmlkZWQgb3IgZGlzY292ZXJlZC5cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8Y29sdW1ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY2h1bmssIGNvbHVtbnNbaV0ua2V5KTtcbiAgICAgICAgICBjb25zdCBbZXJyLCB2YWx1ZV0gPSB0aGlzLl9fY2FzdChmaWVsZCwge1xuICAgICAgICAgICAgaW5kZXg6IGksIGNvbHVtbjogY29sdW1uc1tpXS5rZXksIHJlY29yZHM6IHRoaXMuaW5mby5yZWNvcmRzLCBoZWFkZXI6IGNodW5rSXNIZWFkZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZihlcnIpIHJldHVybiBbZXJyXTtcbiAgICAgICAgICByZWNvcmRbaV0gPSBbdmFsdWUsIGZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNzdnJlY29yZCA9ICcnO1xuICAgICAgZm9yKGxldCBpPTA7IGk8cmVjb3JkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IG9wdGlvbnMsIGVycjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGxldCBbdmFsdWUsIGZpZWxkXSA9IHJlY29yZFtpXTtcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9ZWxzZSBpZihpc19vYmplY3QodmFsdWUpKXtcbiAgICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGlmKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKXtcbiAgICAgICAgICAgIGlmKGVycikgcmV0dXJuIFtFcnJvcihgSW52YWxpZCBDYXN0aW5nIFZhbHVlOiByZXR1cm5lZCB2YWx1ZSBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnMgPSB7Li4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zfTtcbiAgICAgICAgICBbZXJyLCBvcHRpb25zXSA9IG5vcm1hbGl6ZV9vcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBbZXJyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIGlmKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICByZXR1cm4gW0Vycm9yKGBJbnZhbGlkIENhc3RpbmcgVmFsdWU6IHJldHVybmVkIHZhbHVlIG11c3QgcmV0dXJuIGEgc3RyaW5nLCBhbiBvYmplY3QsIG51bGwgb3IgdW5kZWZpbmVkLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtkZWxpbWl0ZXIsIGVzY2FwZSwgcXVvdGUsIHF1b3RlZCwgcXVvdGVkX2VtcHR5LCBxdW90ZWRfc3RyaW5nLCBxdW90ZWRfbWF0Y2gsIHJlY29yZF9kZWxpbWl0ZXIsIGVzY2FwZV9mb3JtdWxhc30gPSBvcHRpb25zO1xuICAgICAgICBpZignJyA9PT0gdmFsdWUgJiYgJycgPT09IGZpZWxkKXtcbiAgICAgICAgICBsZXQgcXVvdGVkTWF0Y2ggPSBxdW90ZWRfbWF0Y2ggJiYgcXVvdGVkX21hdGNoLmZpbHRlcihxdW90ZWRfbWF0Y2ggPT4ge1xuICAgICAgICAgICAgaWYodHlwZW9mIHF1b3RlZF9tYXRjaCA9PT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihxdW90ZWRfbWF0Y2gpICE9PSAtMTtcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlZF9tYXRjaC50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBxdW90ZWRNYXRjaCA9IHF1b3RlZE1hdGNoICYmIHF1b3RlZE1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkUXVvdGUgPSBxdW90ZWRNYXRjaCB8fCB0cnVlID09PSBxdW90ZWRfZW1wdHkgfHxcbiAgICAgICAgICAgICh0cnVlID09PSBxdW90ZWRfc3RyaW5nICYmIGZhbHNlICE9PSBxdW90ZWRfZW1wdHkpO1xuICAgICAgICAgIGlmKHNob3VsZFF1b3RlID09PSB0cnVlKXtcbiAgICAgICAgICAgIHZhbHVlID0gcXVvdGUgKyB2YWx1ZSArIHF1b3RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gdmFsdWU7XG4gICAgICAgIH1lbHNlIGlmKHZhbHVlKXtcbiAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIHJldHVybiBbRXJyb3IoYEZvcm1hdHRlciBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnRhaW5zZGVsaW1pdGVyID0gZGVsaW1pdGVyLmxlbmd0aCAmJiB2YWx1ZS5pbmRleE9mKGRlbGltaXRlcikgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc1F1b3RlID0gKHF1b3RlICE9PSAnJykgJiYgdmFsdWUuaW5kZXhPZihxdW90ZSkgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc0VzY2FwZSA9IHZhbHVlLmluZGV4T2YoZXNjYXBlKSA+PSAwICYmIChlc2NhcGUgIT09IHF1b3RlKTtcbiAgICAgICAgICBjb25zdCBjb250YWluc1JlY29yZERlbGltaXRlciA9IHZhbHVlLmluZGV4T2YocmVjb3JkX2RlbGltaXRlcikgPj0gMDtcbiAgICAgICAgICBjb25zdCBxdW90ZWRTdHJpbmcgPSBxdW90ZWRfc3RyaW5nICYmIHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgbGV0IHF1b3RlZE1hdGNoID0gcXVvdGVkX21hdGNoICYmIHF1b3RlZF9tYXRjaC5maWx0ZXIocXVvdGVkX21hdGNoID0+IHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBxdW90ZWRfbWF0Y2ggPT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YocXVvdGVkX21hdGNoKSAhPT0gLTE7XG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBxdW90ZWRfbWF0Y2gudGVzdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcXVvdGVkTWF0Y2ggPSBxdW90ZWRNYXRjaCAmJiBxdW90ZWRNYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChlc2NhcGVfZm9ybXVsYXMgJiYgWyc9JywgJysnLCAnLScsICdAJywgJ1xcdCcsICdcXHInXS5pbmNsdWRlcyh2YWx1ZVswXSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYCcke3ZhbHVlfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNob3VsZFF1b3RlID0gY29udGFpbnNRdW90ZSA9PT0gdHJ1ZSB8fCBjb250YWluc2RlbGltaXRlciB8fCBjb250YWluc1JlY29yZERlbGltaXRlciB8fCBxdW90ZWQgfHwgcXVvdGVkU3RyaW5nIHx8IHF1b3RlZE1hdGNoO1xuICAgICAgICAgIGlmKHNob3VsZFF1b3RlID09PSB0cnVlICYmIGNvbnRhaW5zRXNjYXBlID09PSB0cnVlKXtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4cCA9IGVzY2FwZSA9PT0gJ1xcXFwnXG4gICAgICAgICAgICAgID8gbmV3IFJlZ0V4cChlc2NhcGUgKyBlc2NhcGUsICdnJylcbiAgICAgICAgICAgICAgOiBuZXcgUmVnRXhwKGVzY2FwZSwgJ2cnKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZWdleHAsIGVzY2FwZSArIGVzY2FwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGNvbnRhaW5zUXVvdGUgPT09IHRydWUpe1xuICAgICAgICAgICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChxdW90ZSwnZycpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlZ2V4cCwgZXNjYXBlICsgcXVvdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihzaG91bGRRdW90ZSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICB2YWx1ZSA9IHF1b3RlICsgdmFsdWUgKyBxdW90ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3N2cmVjb3JkICs9IHZhbHVlO1xuICAgICAgICB9ZWxzZSBpZihxdW90ZWRfZW1wdHkgPT09IHRydWUgfHwgKGZpZWxkID09PSAnJyAmJiBxdW90ZWRfc3RyaW5nID09PSB0cnVlICYmIHF1b3RlZF9lbXB0eSAhPT0gZmFsc2UpKXtcbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gcXVvdGUgKyBxdW90ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihpICE9PSByZWNvcmQubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgY3N2cmVjb3JkICs9IGRlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIGNzdnJlY29yZF07XG4gICAgfSxcbiAgICBib206IGZ1bmN0aW9uKHB1c2gpe1xuICAgICAgaWYodGhpcy5vcHRpb25zLmJvbSAhPT0gdHJ1ZSl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHB1c2goYm9tX3V0ZjgpO1xuICAgIH0sXG4gICAgaGVhZGVyczogZnVuY3Rpb24ocHVzaCl7XG4gICAgICBpZih0aGlzLm9wdGlvbnMuaGVhZGVyID09PSBmYWxzZSl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZXJyO1xuICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuY29sdW1ucy5tYXAoY29sdW1uID0+IGNvbHVtbi5oZWFkZXIpO1xuICAgICAgaWYodGhpcy5vcHRpb25zLmVvZil7XG4gICAgICAgIFtlcnIsIGhlYWRlcnNdID0gdGhpcy5zdHJpbmdpZnkoaGVhZGVycywgdHJ1ZSk7XG4gICAgICAgIGhlYWRlcnMgKz0gdGhpcy5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXI7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIFtlcnIsIGhlYWRlcnNdID0gdGhpcy5zdHJpbmdpZnkoaGVhZGVycyk7XG4gICAgICB9XG4gICAgICBpZihlcnIpIHJldHVybiBlcnI7XG4gICAgICBwdXNoKGhlYWRlcnMpO1xuICAgIH0sXG4gICAgX19jYXN0OiBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCl7XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdHJ5e1xuICAgICAgICBpZih0eXBlID09PSAnc3RyaW5nJyl7IC8vIEZpbmUgZm9yIDk5JSBvZiB0aGUgY2FzZXNcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3Quc3RyaW5nKHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH1lbHNlIGlmKHR5cGUgPT09ICdiaWdpbnQnKXtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3QuYmlnaW50KHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH1lbHNlIGlmKHR5cGUgPT09ICdudW1iZXInKXtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3QubnVtYmVyKHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH1lbHNlIGlmKHR5cGUgPT09ICdib29sZWFuJyl7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0LmJvb2xlYW4odmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfWVsc2UgaWYodmFsdWUgaW5zdGFuY2VvZiBEYXRlKXtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3QuZGF0ZSh2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9ZWxzZSBpZih0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCl7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0Lm9iamVjdCh2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHZhbHVlLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuY2xhc3MgU3RyaW5naWZpZXIgZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KXtcbiAgICBzdXBlcih7Li4ue3dyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZX0sIC4uLm9wdHN9KTtcbiAgICBjb25zdCBbZXJyLCBvcHRpb25zXSA9IG5vcm1hbGl6ZV9vcHRpb25zKG9wdHMpO1xuICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gICAgLy8gRXhwb3NlIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIEludGVybmFsIHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0b3A6IGZhbHNlXG4gICAgfTtcbiAgICAvLyBJbmZvcm1hdGlvblxuICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgIHJlY29yZHM6IDBcbiAgICB9O1xuICAgIHRoaXMuYXBpID0gc3RyaW5naWZpZXIodGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLmluZm8pO1xuICAgIHRoaXMuYXBpLm9wdGlvbnMub25fcmVjb3JkID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgncmVjb3JkJywgLi4uYXJncyk7XG4gICAgfTtcbiAgfVxuICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuc3RhdGUuc3RvcCA9PT0gdHJ1ZSl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVyciA9IHRoaXMuYXBpLl9fdHJhbnNmb3JtKGNodW5rLCB0aGlzLnB1c2guYmluZCh0aGlzKSk7XG4gICAgaWYoZXJyICE9PSB1bmRlZmluZWQpe1xuICAgICAgdGhpcy5zdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICB9XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfVxuICBfZmx1c2goY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuc3RhdGUuc3RvcCA9PT0gdHJ1ZSl7XG4gICAgICAvLyBOb3RlLCBOb2RlLmpzIDEyIGNhbGwgZmx1c2ggZXZlbiBhZnRlciBhbiBlcnJvciwgd2UgbXVzdCBwcmV2ZW50XG4gICAgICAvLyBgY2FsbGJhY2tgIGZyb20gYmVpbmcgY2FsbGVkIGluIGZsdXNoIHdpdGhvdXQgYW55IGVycm9yLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZih0aGlzLmluZm8ucmVjb3JkcyA9PT0gMCl7XG4gICAgICB0aGlzLmFwaS5ib20odGhpcy5wdXNoLmJpbmQodGhpcykpO1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5hcGkuaGVhZGVycyh0aGlzLnB1c2guYmluZCh0aGlzKSk7XG4gICAgICBpZihlcnIpIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuY29uc3Qgc3RyaW5naWZ5ID0gZnVuY3Rpb24oKXtcbiAgbGV0IGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrO1xuICBmb3IoY29uc3QgaSBpbiBhcmd1bWVudHMpe1xuICAgIGNvbnN0IGFyZ3VtZW50ID0gYXJndW1lbnRzW2ldO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJndW1lbnQ7XG4gICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkICYmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkpe1xuICAgICAgZGF0YSA9IGFyZ3VtZW50O1xuICAgIH1lbHNlIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiBpc19vYmplY3QoYXJndW1lbnQpKXtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudDtcbiAgICB9ZWxzZSBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGUgPT09ICdmdW5jdGlvbicpe1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudDtcbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX0FSR1VNRU5UJywgW1xuICAgICAgICAnSW52YWxpZCBhcmd1bWVudDonLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkoYXJndW1lbnQpfSBhdCBpbmRleCAke2l9YFxuICAgICAgXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0cmluZ2lmaWVyID0gbmV3IFN0cmluZ2lmaWVyKG9wdGlvbnMpO1xuICBpZihjYWxsYmFjayl7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgc3RyaW5naWZpZXIub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKXtcbiAgICAgIGxldCBjaHVuaztcbiAgICAgIHdoaWxlKChjaHVuayA9IHRoaXMucmVhZCgpKSAhPT0gbnVsbCl7XG4gICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdHJpbmdpZmllci5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICBzdHJpbmdpZmllci5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgY2h1bmtzLmpvaW4oJycpKTtcbiAgICB9KTtcbiAgfVxuICBpZihkYXRhICE9PSB1bmRlZmluZWQpe1xuICAgIGNvbnN0IHdyaXRlciA9IGZ1bmN0aW9uKCl7XG4gICAgICBmb3IoY29uc3QgcmVjb3JkIG9mIGRhdGEpe1xuICAgICAgICBzdHJpbmdpZmllci53cml0ZShyZWNvcmQpO1xuICAgICAgfVxuICAgICAgc3RyaW5naWZpZXIuZW5kKCk7XG4gICAgfTtcbiAgICAvLyBTdXBwb3J0IERlbm8sIFJvbGx1cCBkb2VzbnQgcHJvdmlkZSBhIHNoaW0gZm9yIHNldEltbWVkaWF0ZVxuICAgIGlmKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpe1xuICAgICAgc2V0SW1tZWRpYXRlKHdyaXRlcik7XG4gICAgfWVsc2Uge1xuICAgICAgc2V0VGltZW91dCh3cml0ZXIsIDApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5naWZpZXI7XG59O1xuXG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/csv/dist/cjs/index.cjs\n");

/***/ })

});